{
  "text": "17.1. Synchronization The Java programming language provides multiple mechanisms for communicating between threads. The most basic of these methods is synchronization , which is implemented using monitors . Each object in Java is associated with a monitor, which a thread can lock or unlock . Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor. A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation. The synchronized statement ( §14.19 ) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. A synchronized method ( §8.4.3.6 ) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static , it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary. Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.",
  "metadata": {
    "java_version": "17",
    "section_number": "17",
    "section_title": "Chapter 17. Threads and Locks",
    "chapter_title": "Chapter 17. Threads and Locks"
  },
  "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html",
  "section_name": "threads_and_locks",
  "downloaded_at": "2025-05-27T13:21:03.526148"
}