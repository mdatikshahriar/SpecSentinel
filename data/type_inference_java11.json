{
  "text": "18.1. Concepts and Notation This section defines inference variables , constraint formulas , and bounds , as the terms will be used throughout this chapter. It also presents notation. 18.1.1. Inference Variables Inference variables are meta-variables for types - that is, they are special names that allow abstract reasoning about types. To distinguish them from type variables , inference variables are represented with Greek letters, principally α . The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables. The term proper type excludes such \"types\" that mention inference variables. Assertions that involve inference variables are assertions about every proper type that can be produced by replacing each inference variable with a proper type. 18.1.2. Constraint Formulas Constraint formulas are assertions of compatibility or subtyping that may involve inference variables. The formulas may take one of the following forms: ‹ Expression → T ›: An expression is compatible in a loose invocation context with type T ( §5.3 ). ‹ S → T ›: A type S is compatible in a loose invocation context with type T ( §5.3 ). ‹ S <: T ›: A reference type S is a subtype of a reference type T ( §4.10 ). ‹ S <= T ›: A type argument S is contained by a type argument T ( §4.5.1 ). ‹ S = T ›: A type S is the same as a type T ( §4.3.4 ), or a type argument S is the same as type argument T . ‹ LambdaExpression → throws T ›: The checked exceptions thrown by the body of the LambdaExpression are declared by the throws clause of the function type derived from T . ‹ MethodReference → throws T ›: The checked exceptions thrown by the referenced method are declared by the throws clause of the function type derived from T . Examples of constraint formulas: From Collections.singleton(\"hi\") , we have the constraint formula ‹ \"hi\" → α ›. Through reduction, this will become the constraint formula: ‹ String <: α ›. From Arrays.asList(1, 2.0) , we have the constraint formulas ‹ 1 → α › and ‹ 2.0 → α ›. Through reduction, these will become the constraint formulas ‹ int → α › and ‹ double → α ›, and then ‹ Integer <: α › and ‹ Double <: α ›. From the target type of the constructor invocation List<Thread> lt = new ArrayList <> () , we have the constraint formula ‹ ArrayList < α > → List < Thread > ›. Through reduction, this will become the constraint formula ‹ α <= Thread ›, and then ‹ α = Thread ›. 18.1.3. Bounds During the inference process, a set of bounds on inference variables is maintained. A bound has one of the following forms: S = T , where at least one of S or T is an inference variable: S is the same as T . S <: T , where at least one of S or T is an inference variable: S is a subtype of T . false : No valid choice of inference variables exists. G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ): The variables α 1 , ..., α n represent the result of capture conversion ( §5.1.10 ) applied to G < A 1 , ..., A n > (where A 1 , ..., A n may be types or wildcards and may mention inference variables). throws α : The inference variable α appears in a throws clause. A bound is satisfied by an inference variable substitution if, after applying the substitution, the assertion is true. The bound false can never be satisfied. Some bounds relate an inference variable to a proper type. Let T be a proper type. Given a bound of the form α = T or T = α , we say T is an instantiation of α . Similarly, given a bound of the form α <: T , we say T is a proper upper bound of α , and given a bound of the form T <: α , we say T is a proper lower bound of α . Other bounds relate two inference variables, or an inference variable to a type that contains inference variables. Such bounds, of the form S = T or S <: T , are called dependencies . A bound of the form G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ) indicates that α 1 , ..., α n are placeholders for the results of capture conversion. This is necessary because capture conversion can only be performed on a proper type, and the inference variables in A 1 , ..., A n may not yet be resolved. A bound of the form throws α is purely informational: it directs resolution to optimize the instantiation of α so that, if possible, it is not a checked exception type. An important intermediate result of inference is a bound set . It is sometimes convenient to refer to an empty bound set with the symbol true ; this is merely out of convenience, and the two are interchangeable. Examples of bound sets: { α = String } contains a single bound, instantiating α as String . { Integer <: α , Double <: α , α <: Object } describes two proper lower bounds and one proper upper bound for α . { α <: Iterable<?> , β <: Object , α <: List < β > } describes a proper upper bound for each of α and β , along with a dependency between them. { } contains no bounds nor dependencies, and can be referred to as true . { false } expresses the fact that no satisfactory instantiation exists. When inference begins, a bound set is typically generated from a list of type parameter declarations P 1 , ..., P p and associated inference variables α 1 , ..., α p . Such a bound set is generated as follows. For each l (1 ≤ l ≤ p ): If P l has no TypeBound , the bound α l <: Object appears in the set. Otherwise, for each type T delimited by & in the TypeBound , the bound α l <: T [ P 1 := α 1 , ..., P p := α p ] appears in the set; if this results in no proper upper bounds for α l (only dependencies), then the bound α l <: Object also appears in the set.",
  "metadata": {
    "java_version": "11",
    "section_number": "18",
    "section_title": "Chapter 18. Type Inference",
    "chapter_title": "Unknown"
  },
  "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-18.html",
  "section_name": "type_inference",
  "downloaded_at": "2025-05-27T13:21:09.793664"
}