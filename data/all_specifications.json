{
  "method_resolution_java8": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations. An expression occurs in either: The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on a package declaration or on a top level type declaration.",
    "metadata": {
      "java_version": "8",
      "section_number": "15.12",
      "section_title": "Unknown",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "section_name": "method_resolution",
    "downloaded_at": "2025-05-27T13:19:28.759582"
  },
  "method_resolution_java11": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations. An expression occurs in either: The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on a package declaration or on a top level type declaration.",
    "metadata": {
      "java_version": "11",
      "section_number": "15.12",
      "section_title": "Unknown",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12",
    "section_name": "method_resolution",
    "downloaded_at": "2025-05-27T13:19:30.820110"
  },
  "method_resolution_java17": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on the declaration of a module, a package, or a top level class or interface.",
    "metadata": {
      "java_version": "17",
      "section_number": "15.12",
      "section_title": "Unknown",
      "chapter_title": "Chapter 15. Expressions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12",
    "section_name": "method_resolution",
    "downloaded_at": "2025-05-27T13:19:33.575607"
  },
  "method_resolution_java21": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on the declaration of a module, a package, or a top level class or interface.",
    "metadata": {
      "java_version": "21",
      "section_number": "15.12",
      "section_title": "Unknown",
      "chapter_title": "Chapter 15. Expressions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12",
    "section_name": "method_resolution",
    "downloaded_at": "2025-05-27T13:19:35.616596"
  },
  "method_resolution_java24": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on the declaration of a module, a package, or a top level class or interface.",
    "metadata": {
      "java_version": "24",
      "section_number": "15.12",
      "section_title": "Unknown",
      "chapter_title": "Chapter 15. Expressions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12",
    "section_name": "method_resolution",
    "downloaded_at": "2025-05-27T13:19:37.658357"
  },
  "switch_statement_java8": {
    "text": "14.1. Normal and Abrupt Completion of Statements Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement. If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to complete normally . However, certain events may prevent a statement from completing normally: The break ( §14.15 ), continue ( §14.16 ), and return ( §14.17 ) statements cause a transfer of control that may prevent normal completion of statements that contain them. Evaluation of certain expressions may throw exceptions from the Java Virtual Machine ( §15.6 ). An explicit throw ( §14.18 ) statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements. If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to complete abruptly . An abrupt completion always has an associated reason , which is one of the following: A break with no label A break with a given label A continue with no label A continue with a given label A return with no value A return with a given value A throw with a given value, including exceptions thrown by the Java Virtual Machine The terms \"complete normally\" and \"complete abruptly\" also apply to the evaluation of expressions ( §15.6 ). The only reason an expression can complete abruptly is that an exception is thrown, because of either a throw with a given value ( §14.18 ) or a run-time exception or error ( §11 ( Exceptions ) , §15.6 ). If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed. Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed. Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.",
    "metadata": {
      "java_version": "8",
      "section_number": "14.11",
      "section_title": "Unknown",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.11",
    "section_name": "switch_statement",
    "downloaded_at": "2025-05-27T13:19:40.141897"
  },
  "switch_statement_java11": {
    "text": "14.1. Normal and Abrupt Completion of Statements Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement. If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to complete normally . However, certain events may prevent a statement from completing normally: The break ( §14.15 ), continue ( §14.16 ), and return ( §14.17 ) statements cause a transfer of control that may prevent normal completion of statements that contain them. Evaluation of certain expressions may throw exceptions from the Java Virtual Machine ( §15.6 ). An explicit throw ( §14.18 ) statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements. If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to complete abruptly . An abrupt completion always has an associated reason , which is one of the following: A break with no label A break with a given label A continue with no label A continue with a given label A return with no value A return with a given value A throw with a given value, including exceptions thrown by the Java Virtual Machine The terms \"complete normally\" and \"complete abruptly\" also apply to the evaluation of expressions ( §15.6 ). The only reason an expression can complete abruptly is that an exception is thrown, because of either a throw with a given value ( §14.18 ) or a run-time exception or error ( §11 ( Exceptions ) , §15.6 ). If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed. Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed. Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.",
    "metadata": {
      "java_version": "11",
      "section_number": "14.11",
      "section_title": "Unknown",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.11",
    "section_name": "switch_statement",
    "downloaded_at": "2025-05-27T13:19:41.779261"
  },
  "switch_statement_java17": {
    "text": "14.1. Normal and Abrupt Completion of Statements Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement. If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to complete normally . However, certain events may prevent a statement from completing normally: The break , yield , continue , and return statements ( §14.15 , §14.21 , §14.16 , §14.17 ) cause a transfer of control that may prevent normal completion of expressions, statements, and blocks that contain them. Evaluation of certain expressions may throw exceptions from the Java Virtual Machine ( §15.6 ). An explicit throw ( §14.18 ) statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements. If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to complete abruptly . An abrupt completion always has an associated reason , which is one of the following: A break with no label A break with a given label A continue with no label A continue with a given label A return with no value A return with a given value A throw with a given value, including exceptions thrown by the Java Virtual Machine A yield with a given value The terms \"complete normally\" and \"complete abruptly\" also apply to the evaluation of expressions ( §15.6 ). The only reason an expression can complete abruptly is that an exception is thrown, because of either a throw with a given value ( §14.18 ) or a run-time exception or error ( §11 ( Exceptions ) , §15.6 ). If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed. Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed. Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.",
    "metadata": {
      "java_version": "17",
      "section_number": "14.11",
      "section_title": "Unknown",
      "chapter_title": "Chapter 14. Blocks, Statements, and Patterns"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-14.html#jls-14.11",
    "section_name": "switch_statement",
    "downloaded_at": "2025-05-27T13:19:43.267373"
  },
  "switch_statement_java21": {
    "text": "14.1. Normal and Abrupt Completion of Statements Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement. If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to complete normally . However, certain events may prevent a statement from completing normally: The break , yield , continue , and return statements ( §14.15 , §14.21 , §14.16 , §14.17 ) cause a transfer of control that may prevent normal completion of expressions, statements, and blocks that contain them. Evaluation of certain expressions may throw exceptions from the Java Virtual Machine ( §15.6 ). An explicit throw ( §14.18 ) statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements. If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to complete abruptly . An abrupt completion always has an associated reason , which is one of the following: A break with no label A break with a given label A continue with no label A continue with a given label A return with no value A return with a given value A throw with a given value, including exceptions thrown by the Java Virtual Machine A yield with a given value The terms \"complete normally\" and \"complete abruptly\" also apply to the evaluation of expressions ( §15.6 ). The only reason an expression can complete abruptly is that an exception is thrown, because of either a throw with a given value ( §14.18 ) or a run-time exception or error ( §11 ( Exceptions ) , §15.6 ). If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed. Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed. Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.",
    "metadata": {
      "java_version": "21",
      "section_number": "14.11",
      "section_title": "Unknown",
      "chapter_title": "Chapter 14. Blocks, Statements, and Patterns"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-14.11",
    "section_name": "switch_statement",
    "downloaded_at": "2025-05-27T13:19:44.852937"
  },
  "switch_statement_java24": {
    "text": "14.1. Normal and Abrupt Completion of Statements Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement. If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to complete normally . However, certain events may prevent a statement from completing normally: The break , yield , continue , and return statements ( §14.15 , §14.21 , §14.16 , §14.17 ) cause a transfer of control that may prevent normal completion of expressions, statements, and blocks that contain them. Evaluation of certain expressions may throw exceptions from the Java Virtual Machine ( §15.6 ). An explicit throw ( §14.18 ) statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements. If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to complete abruptly . An abrupt completion always has an associated reason , which is one of the following: A break with no label A break with a given label A continue with no label A continue with a given label A return with no value A return with a given value A throw with a given value, including exceptions thrown by the Java Virtual Machine A yield with a given value The terms \"complete normally\" and \"complete abruptly\" also apply to the evaluation of expressions ( §15.6 ). The only reason an expression can complete abruptly is that an exception is thrown, because of either a throw with a given value ( §14.18 ) or a run-time exception or error ( §11 ( Exceptions ) , §15.6 ). If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed. Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed. Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.",
    "metadata": {
      "java_version": "24",
      "section_number": "14.11",
      "section_title": "Unknown",
      "chapter_title": "Chapter 14. Blocks, Statements, and Patterns"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-14.html#jls-14.11",
    "section_name": "switch_statement",
    "downloaded_at": "2025-05-27T13:19:46.431836"
  },
  "inheritance_java8": {
    "text": "8.1. Class Declarations A class declaration specifies a new named reference type. There are two kinds of class declarations: normal class declarations and enum declarations . ClassDeclaration: NormalClassDeclaration EnumDeclaration NormalClassDeclaration: { ClassModifier } class Identifier [ TypeParameters ] [ Superclass ] [ Superinterfaces ] ClassBody The rules in this section apply to all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to class modifiers, inner classes, and superclasses; these rules are stated in §8.9 . The Identifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final strictfp The rules for annotation modifiers on a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes within a directly enclosing class declaration ( §8.5 ). The modifier static pertains only to member classes ( §8.5.1 ), not to top level or local or anonymous classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration. If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. final Classes A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if the name of a final class appears in the extends clause ( §8.1.4 ) of another class declaration; this implies that a final class cannot have any subclasses. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). 8.1.1.3. strictfp Classes The effect of the strictfp modifier is to make all float or double expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict ( §15.4 ). This implies that all methods declared in the class, and all nested types declared in the class, are implicitly strictfp . 8.1.2. Generic Classes and Type Parameters A class is generic if it declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } Identifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules for annotation modifiers on a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. It is a compile-time error to refer to a type parameter of a generic class C in any of the following: the declaration of a static member of C ( §8.3.1.1 , §8.4.3.2 , §8.5.1 ). the declaration of a static member of any type declaration nested within C . a static initializer of C ( §8.7 ), or a static initializer of any class declaration nested within C . Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly declared static . An inner class may be a non- static member class ( §8.5 ), a local class ( §14.3 ), or an anonymous class ( §15.9.5 ). A member class of an interface is implicitly static ( §9.5 ) so is never considered to be an inner class. It is a compile-time error if an inner class declares a static initializer ( §8.7 ). It is a compile-time error if an inner class declares a member that is explicitly or implicitly static , unless the member is a constant variable ( §4.12.4 ). An inner class may inherit static members that are not constant variables even though it cannot declare them. A nested class that is not an inner class may declare static members freely, in accordance with the usual rules of the Java programming language. Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static final int x = 3; // OK: constant variable static int y = 4; // Compile-time error: an inner class } static class NestedButNotInner{ static int z = 5; // OK: not an inner class } interface NeverInner {} // Interfaces are never inner } A statement or expression occurs in a static context if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement ( §8.8.7.1 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing type declaration of C and the declaration of C does not occur in a static context. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing type declaration of an inner class to be an interface. This only occurs if the class is declared in a default method body ( §9.4 ). Specifically, it occurs if an anonymous or local class is declared in a default method body, or a member class is declared in the body of an anonymous class that is declared in a default method body. A class or interface O is the zeroth lexically enclosing type declaration of itself . A class O is the n'th lexically enclosing type declaration of a class C if it is the immediately enclosing type declaration of the n-1 'th lexically enclosing type declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner class I whose declaration occurs in a static context has no lexically enclosing instances. However, if I is immediately declared within a static method or static initializer then I does have an enclosing block , which is the innermost block statement lexically enclosing the declaration of I . For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing type declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared final or be effectively final ( §4.12.4 ), or a compile-time error occurs where the use is attempted. Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing type declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are marked final ). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing type declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing type declaration, the instance variable must be defined with respect to an enclosing instance of that declared type. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass of the current class. Superclass: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass. The ClassType must name an accessible class type ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum or any invocation of Enum ( §8.9 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superclass of the class type C < F 1 ,..., F n > is the type given in the extends clause of the declaration of C if an extends clause is present, or Object otherwise. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superclass of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, is D < U 1 θ ,..., U k θ > , where D < U 1 ,..., U k > is the direct superclass of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . A class is said to be a direct subclass of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived. The subclass relationship is the transitive closure of the direct subclass relationship. A class A is a subclass of class C if either of the following is true: A is the direct subclass of C There exists a class B such that A is a subclass of B , and B is a subclass of C , applying this definition recursively. Class C is said to be a superclass of class A whenever A is a subclass of C . Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a reference type T if any of the following is true: C directly depends on T . C directly depends on an interface I that depends ( §9.1.3 ) on T . C directly depends on a class D that depends on T (using this definition recursively). It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration lists the names of interfaces that are direct superinterfaces of the class being declared. Superinterfaces: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface type ( §6.6 ), or a compile-time error occurs. If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is mentioned as a direct superinterface more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superinterfaces of the class type C < F 1 ,..., F n > are the types given in the implements clause of the declaration of C , if an implements clause is present. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superinterfaces of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, are all types I < U 1 θ ,..., U k θ > , where I < U 1 ,..., U k > is a direct superinterface of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . An interface type I is a superinterface of class type C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to implement all its superinterfaces. A class may not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface ( §9.1.2 ), or a subtype of a parameterization of a generic interface and a raw type naming that same generic interface, or a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-3. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes ( §8.5 ), and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class type C is specified in §6.3 and §6.4 . If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows ( §6.4.1 ) the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "8",
      "section_number": "8.4.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.8",
    "section_name": "inheritance",
    "downloaded_at": "2025-05-27T13:19:48.042225"
  },
  "inheritance_java11": {
    "text": "8.1. Class Declarations A class declaration specifies a new named reference type. There are two kinds of class declarations: normal class declarations and enum declarations . ClassDeclaration: NormalClassDeclaration EnumDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ Superclass ] [ Superinterfaces ] ClassBody The rules in this section apply to all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to class modifiers, inner classes, and superclasses; these rules are stated in §8.9 . The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final strictfp The rules for annotation modifiers on a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes within a directly enclosing class declaration ( §8.5 ). The modifier static pertains only to member classes ( §8.5.1 ), not to top level or local or anonymous classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private ( §6.6 ). If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. final Classes A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if the name of a final class appears in the extends clause ( §8.1.4 ) of another class declaration; this implies that a final class cannot have any subclasses. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). 8.1.1.3. strictfp Classes The effect of the strictfp modifier is to make all float or double expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict ( §15.4 ). This implies that all methods declared in the class, and all nested types declared in the class, are implicitly strictfp . 8.1.2. Generic Classes and Type Parameters A class is generic if it declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules for annotation modifiers on a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. It is a compile-time error to refer to a type parameter of a generic class C in any of the following: the declaration of a static member of C ( §8.3.1.1 , §8.4.3.2 , §8.5.1 ). the declaration of a static member of any type declaration nested within C . a static initializer of C ( §8.7 ), or a static initializer of any class declaration nested within C . Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly declared static . An inner class may be a non- static member class ( §8.5 ), a local class ( §14.3 ), or an anonymous class ( §15.9.5 ). A member class of an interface is implicitly static ( §9.5 ) so is never considered to be an inner class. It is a compile-time error if an inner class declares a static initializer ( §8.7 ). It is a compile-time error if an inner class declares a member that is explicitly or implicitly static , unless the member is a constant variable ( §4.12.4 ). An inner class may inherit static members that are not constant variables even though it cannot declare them. A nested class that is not an inner class may declare static members freely, in accordance with the usual rules of the Java programming language. Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static final int x = 3; // OK: constant variable static int y = 4; // Compile-time error: an inner class } static class NestedButNotInner{ static int z = 5; // OK: not an inner class } interface NeverInner {} // Interfaces are never inner } A statement or expression occurs in a static context if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement ( §8.8.7.1 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing type declaration of C and the declaration of C does not occur in a static context. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing type declaration of an inner class to be an interface. This only occurs if the class is declared in a default method body ( §9.4 ). Specifically, it occurs if an anonymous or local class is declared in a default method body, or a member class is declared in the body of an anonymous class that is declared in a default method body. A class or interface O is the zeroth lexically enclosing type declaration of itself . A class O is the n'th lexically enclosing type declaration of a class C if it is the immediately enclosing type declaration of the n-1 'th lexically enclosing type declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner class I whose declaration occurs in a static context has no lexically enclosing instances. However, if I is immediately declared within a static method or static initializer then I does have an enclosing block , which is the innermost block statement lexically enclosing the declaration of I . For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing type declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared final or be effectively final ( §4.12.4 ), or a compile-time error occurs where the use is attempted. Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing type declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing type declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing type declaration, the instance variable must be defined with respect to an enclosing instance of that declared type. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass of the current class. Superclass: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass. The ClassType must name an accessible class type ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum or any invocation of Enum ( §8.9 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superclass of the class type C < F 1 ,..., F n > is the type given in the extends clause of the declaration of C if an extends clause is present, or Object otherwise. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superclass of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, is D < U 1 θ ,..., U k θ > , where D < U 1 ,..., U k > is the direct superclass of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . A class is said to be a direct subclass of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived. The subclass relationship is the transitive closure of the direct subclass relationship. A class A is a subclass of class C if either of the following is true: A is the direct subclass of C There exists a class B such that A is a subclass of B , and B is a subclass of C , applying this definition recursively. Class C is said to be a superclass of class A whenever A is a subclass of C . Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a reference type T if any of the following is true: C directly depends on T . C directly depends on an interface I that depends ( §9.1.3 ) on T . C directly depends on a class D that depends on T (using this definition recursively). It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration lists the names of interfaces that are direct superinterfaces of the class being declared. Superinterfaces: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface type ( §6.6 ), or a compile-time error occurs. If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is mentioned as a direct superinterface more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superinterfaces of the class type C < F 1 ,..., F n > are the types given in the implements clause of the declaration of C , if an implements clause is present. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superinterfaces of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, are all types I < U 1 θ ,..., U k θ > , where I < U 1 ,..., U k > is a direct superinterface of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . An interface type I is a superinterface of class type C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to implement all its superinterfaces. A class may not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface ( §9.1.2 ), or a subtype of a parameterization of a generic interface and a raw type naming that same generic interface, or a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-3. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes ( §8.5 ), and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class type C is specified in §6.3 and §6.4 . If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows ( §6.4.1 ) the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "11",
      "section_number": "8.4.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.8",
    "section_name": "inheritance",
    "downloaded_at": "2025-05-27T13:19:50.279080"
  },
  "inheritance_java17": {
    "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required . Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "17",
      "section_number": "8.4.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Chapter 8. Classes"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.4.8",
    "section_name": "inheritance",
    "downloaded_at": "2025-05-27T13:19:52.093931"
  },
  "inheritance_java21": {
    "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required . Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For a record class R , the direct superclass type is Record . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "21",
      "section_number": "8.4.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Chapter 8. Classes"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.8",
    "section_name": "inheritance",
    "downloaded_at": "2025-05-27T13:19:54.157160"
  },
  "inheritance_java24": {
    "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required. Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For a record class R , the direct superclass type is Record . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "24",
      "section_number": "8.4.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Chapter 8. Classes"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-8.html#jls-8.4.8",
    "section_name": "inheritance",
    "downloaded_at": "2025-05-27T13:19:55.765863"
  },
  "overloading_java8": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations. An expression occurs in either: The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on a package declaration or on a top level type declaration.",
    "metadata": {
      "java_version": "8",
      "section_number": "15.12.2",
      "section_title": "Unknown",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2",
    "section_name": "overloading",
    "downloaded_at": "2025-05-27T13:19:57.794541"
  },
  "overloading_java11": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations. An expression occurs in either: The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on a package declaration or on a top level type declaration.",
    "metadata": {
      "java_version": "11",
      "section_number": "15.12.2",
      "section_title": "Unknown",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12.2",
    "section_name": "overloading",
    "downloaded_at": "2025-05-27T13:20:01.265727"
  },
  "overloading_java17": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on the declaration of a module, a package, or a top level class or interface.",
    "metadata": {
      "java_version": "17",
      "section_number": "15.12.2",
      "section_title": "Unknown",
      "chapter_title": "Chapter 15. Expressions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12.2",
    "section_name": "overloading",
    "downloaded_at": "2025-05-27T13:20:03.336555"
  },
  "overloading_java21": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on the declaration of a module, a package, or a top level class or interface.",
    "metadata": {
      "java_version": "21",
      "section_number": "15.12.2",
      "section_title": "Unknown",
      "chapter_title": "Chapter 15. Expressions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12.2",
    "section_name": "overloading",
    "downloaded_at": "2025-05-27T13:20:05.954412"
  },
  "overloading_java24": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on the declaration of a module, a package, or a top level class or interface.",
    "metadata": {
      "java_version": "24",
      "section_number": "15.12.2",
      "section_title": "Unknown",
      "chapter_title": "Chapter 15. Expressions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12.2",
    "section_name": "overloading",
    "downloaded_at": "2025-05-27T13:20:08.919216"
  },
  "generics_java8": {
    "text": "4.1. The Kinds of Types and Values There are two kinds of types in the Java programming language: primitive types ( §4.2 ) and reference types ( §4.3 ). There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values ( §4.2 ) and reference values ( §4.3 ). Type: PrimitiveType ReferenceType There is also a special null type , the type of the expression null ( §3.10.7 , §15.8.1 ), which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be assigned or cast to any reference type ( §5.2 , §5.3 , §5.5 ). In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.",
    "metadata": {
      "java_version": "8",
      "section_number": "4.5",
      "section_title": "Chapter 4. Types, Values, and Variables",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5",
    "section_name": "generics",
    "downloaded_at": "2025-05-27T13:20:10.448273"
  },
  "generics_java11": {
    "text": "4.1. The Kinds of Types and Values There are two kinds of types in the Java programming language: primitive types ( §4.2 ) and reference types ( §4.3 ). There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values ( §4.2 ) and reference values ( §4.3 ). Type: PrimitiveType ReferenceType There is also a special null type , the type of the expression null ( §3.10.7 , §15.8.1 ), which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be assigned or cast to any reference type ( §5.2 , §5.3 , §5.5 ). In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.",
    "metadata": {
      "java_version": "11",
      "section_number": "4.5",
      "section_title": "Chapter 4. Types, Values, and Variables",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5",
    "section_name": "generics",
    "downloaded_at": "2025-05-27T13:20:11.936412"
  },
  "generics_java17": {
    "text": "4.1. The Kinds of Types and Values There are two kinds of types in the Java programming language: primitive types ( §4.2 ) and reference types ( §4.3 ). There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values ( §4.2 ) and reference values ( §4.3 ). Type: PrimitiveType ReferenceType There is also a special null type , the type of the expression null ( §3.10.8 , §15.8.1 ), which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be assigned or cast to any reference type ( §5.2 , §5.3 , §5.5 ). In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.",
    "metadata": {
      "java_version": "17",
      "section_number": "4.5",
      "section_title": "Chapter 4. Types, Values, and Variables",
      "chapter_title": "Chapter 4. Types, Values, and Variables"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-4.5",
    "section_name": "generics",
    "downloaded_at": "2025-05-27T13:20:13.365806"
  },
  "generics_java21": {
    "text": "4.1. The Kinds of Types and Values There are two kinds of types in the Java programming language: primitive types ( §4.2 ) and reference types ( §4.3 ). There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values ( §4.2 ) and reference values ( §4.3 ). Type: PrimitiveType ReferenceType There is also a special null type , the type of the expression null ( §3.10.8 , §15.8.1 ), which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be assigned or cast to any reference type ( §5.2 , §5.3 , §5.5 ). In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.",
    "metadata": {
      "java_version": "21",
      "section_number": "4.5",
      "section_title": "Chapter 4. Types, Values, and Variables",
      "chapter_title": "Chapter 4. Types, Values, and Variables"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-4.html#jls-4.5",
    "section_name": "generics",
    "downloaded_at": "2025-05-27T13:20:14.956057"
  },
  "generics_java24": {
    "text": "4.1. The Kinds of Types and Values There are two kinds of types in the Java programming language: primitive types ( §4.2 ) and reference types ( §4.3 ). There are, correspondingly, two kinds of data values that can be stored in variables, passed as arguments, returned by methods, and operated on: primitive values ( §4.2 ) and reference values ( §4.3 ). Type: PrimitiveType ReferenceType There is also a special null type , the type of the expression null ( §3.10.8 , §15.8.1 ), which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be assigned or cast to any reference type ( §5.2 , §5.3 , §5.5 ). In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.",
    "metadata": {
      "java_version": "24",
      "section_number": "4.5",
      "section_title": "Chapter 4. Types, Values, and Variables",
      "chapter_title": "Chapter 4. Types, Values, and Variables"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-4.html#jls-4.5",
    "section_name": "generics",
    "downloaded_at": "2025-05-27T13:20:16.389961"
  },
  "exceptions_java8": {
    "text": "11.1. The Kinds and Causes of Exceptions 11.1.1. The Kinds of Exceptions An exception is represented by an instance of the class Throwable (a direct subclass of Object ) or one of its subclasses. Throwable and all its subclasses are, collectively, the exception classes . The classes Exception and Error are direct subclasses of Throwable : Exception is the superclass of all the exceptions from which ordinary programs may wish to recover. The class RuntimeException is a direct subclass of Exception . RuntimeException is the superclass of all the exceptions which may be thrown for many reasons during expression evaluation, but from which recovery may still be possible. RuntimeException and all its subclasses are, collectively, the run-time exception classes . Error is the superclass of all the exceptions from which ordinary programs are not ordinarily expected to recover. Error and all its subclasses are, collectively, the error classes . The unchecked exception classes are the run-time exception classes and the error classes. The checked exception classes are all exception classes other than the unchecked exception classes. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses. Programs can use the pre-existing exception classes of the Java SE platform API in throw statements, or define additional exception classes as subclasses of Throwable or of any of its subclasses, as appropriate. To take advantage of compile-time checking for exception handlers ( §11.2 ), it is typical to define most new exception classes as checked exception classes, that is, as subclasses of Exception that are not subclasses of RuntimeException . The class Error is a separate subclass of Throwable , distinct from Exception in the class hierarchy, to allow programs to use the idiom \" } catch (Exception e) { \" ( §11.2.3 ) to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible. Note that a subclass of Throwable cannot be generic ( §8.1.2 ). 11.1.2. The Causes of Exceptions An exception is thrown for one of three reasons: A throw statement ( §14.18 ) was executed. An abnormal execution condition was synchronously detected by the Java Virtual Machine, namely: evaluation of an expression violates the normal semantics of the Java programming language ( §15.6 ), such as an integer divide by zero. an error occurs while loading, linking, or initializing part of the program ( §12.2 , §12.3 , §12.4 ); in this case, an instance of a subclass of LinkageError is thrown. an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMachineError is thrown. These exceptions are not thrown at an arbitrary point in the program, but rather at a point where they are specified as a possible result of an expression evaluation or statement execution. An asynchronous exception occurred ( §11.1.3 ). 11.1.3. Asynchronous Exceptions Most exceptions occur synchronously as a result of an action by the thread in which they occur, and at a point in the program that is specified to possibly result in such an exception. An asynchronous exception is, by contrast, an exception that can potentially occur at any point in the execution of a program. Asynchronous exceptions occur only as a result of: An invocation of the (deprecated) stop method of class Thread or ThreadGroup . The (deprecated) stop methods may be invoked by one thread to affect another thread or all the threads in a specified thread group. They are asynchronous because they may occur at any point in the execution of the other thread or threads. An internal error or resource limitation in the Java Virtual Machine that prevents it from implementing the semantics of the Java programming language. In this case, the asynchronous exception that is thrown is an instance of a subclass of VirtualMachineError . Note that StackOverflowError , a subclass of VirtualMachineError , may be thrown synchronously by method invocation ( §15.12.4.5 ) as well as asynchronously due to native method execution or Java Virtual Machine resource limitations. Similarly, OutOfMemoryError , another subclass of VirtualMachineError , may be thrown synchronously during class instance creation ( §15.9.4 , §12.5 ), array creation ( §15.10.2 , §10.6 ), class initialization ( §12.4.2 ), and boxing conversion ( §5.1.7 ), as well as asynchronously. The Java SE platform permits a small but bounded amount of execution to occur before an asynchronous exception is thrown. Asynchronous exceptions are rare, but proper understanding of their semantics is necessary if high-quality machine code is to be generated. The delay noted above is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language. A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction. Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception. Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance. The paper Polling Efficiently on Stock Hardware by Marc Feeley, Proc. 1993 Conference on Functional Programming and Computer Architecture , Copenhagen, Denmark, pp. 179-187, is recommended as further reading.",
    "metadata": {
      "java_version": "8",
      "section_number": "11",
      "section_title": "Chapter 11. Exceptions",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-11.html",
    "section_name": "exceptions",
    "downloaded_at": "2025-05-27T13:20:17.497704"
  },
  "exceptions_java11": {
    "text": "11.1. The Kinds and Causes of Exceptions 11.1.1. The Kinds of Exceptions An exception is represented by an instance of the class Throwable (a direct subclass of Object ) or one of its subclasses. Throwable and all its subclasses are, collectively, the exception classes . The classes Exception and Error are direct subclasses of Throwable : Exception is the superclass of all the exceptions from which ordinary programs may wish to recover. The class RuntimeException is a direct subclass of Exception . RuntimeException is the superclass of all the exceptions which may be thrown for many reasons during expression evaluation, but from which recovery may still be possible. RuntimeException and all its subclasses are, collectively, the run-time exception classes . Error is the superclass of all the exceptions from which ordinary programs are not ordinarily expected to recover. Error and all its subclasses are, collectively, the error classes . The unchecked exception classes are the run-time exception classes and the error classes. The checked exception classes are all exception classes other than the unchecked exception classes. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses. Programs can use the pre-existing exception classes of the Java SE Platform API in throw statements, or define additional exception classes as subclasses of Throwable or of any of its subclasses, as appropriate. To take advantage of compile-time checking for exception handlers ( §11.2 ), it is typical to define most new exception classes as checked exception classes, that is, as subclasses of Exception that are not subclasses of RuntimeException . The class Error is a separate subclass of Throwable , distinct from Exception in the class hierarchy, to allow programs to use the idiom \" } catch (Exception e) { \" ( §11.2.3 ) to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible. Note that a subclass of Throwable cannot be generic ( §8.1.2 ). 11.1.2. The Causes of Exceptions An exception is thrown for one of three reasons: A throw statement ( §14.18 ) was executed. An abnormal execution condition was synchronously detected by the Java Virtual Machine, namely: evaluation of an expression violates the normal semantics of the Java programming language ( §15.6 ), such as an integer divide by zero. an error occurs while loading, linking, or initializing part of the program ( §12.2 , §12.3 , §12.4 ); in this case, an instance of a subclass of LinkageError is thrown. an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMachineError is thrown. These exceptions are not thrown at an arbitrary point in the program, but rather at a point where they are specified as a possible result of an expression evaluation or statement execution. An asynchronous exception occurred ( §11.1.3 ). 11.1.3. Asynchronous Exceptions Most exceptions occur synchronously as a result of an action by the thread in which they occur, and at a point in the program that is specified to possibly result in such an exception. An asynchronous exception is, by contrast, an exception that can potentially occur at any point in the execution of a program. Asynchronous exceptions occur only as a result of: An invocation of the (deprecated) stop method of class Thread or ThreadGroup . The (deprecated) stop methods may be invoked by one thread to affect another thread or all the threads in a specified thread group. They are asynchronous because they may occur at any point in the execution of the other thread or threads. An internal error or resource limitation in the Java Virtual Machine that prevents it from implementing the semantics of the Java programming language. In this case, the asynchronous exception that is thrown is an instance of a subclass of VirtualMachineError . Note that StackOverflowError , a subclass of VirtualMachineError , may be thrown synchronously by method invocation ( §15.12.4.5 ) as well as asynchronously due to native method execution or Java Virtual Machine resource limitations. Similarly, OutOfMemoryError , another subclass of VirtualMachineError , may be thrown synchronously during class instance creation ( §15.9.4 , §12.5 ), array creation ( §15.10.2 , §10.6 ), class initialization ( §12.4.2 ), and boxing conversion ( §5.1.7 ), as well as asynchronously. The Java SE Platform permits a small but bounded amount of execution to occur before an asynchronous exception is thrown. Asynchronous exceptions are rare, but proper understanding of their semantics is necessary if high-quality machine code is to be generated. The delay noted above is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language. A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction. Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception. Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance. The paper Polling Efficiently on Stock Hardware by Marc Feeley, Proc. 1993 Conference on Functional Programming and Computer Architecture , Copenhagen, Denmark, pp. 179-187, is recommended as further reading.",
    "metadata": {
      "java_version": "11",
      "section_number": "11",
      "section_title": "Chapter 11. Exceptions",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-11.html",
    "section_name": "exceptions",
    "downloaded_at": "2025-05-27T13:20:18.659075"
  },
  "exceptions_java17": {
    "text": "11.1. The Kinds and Causes of Exceptions 11.1.1. The Kinds of Exceptions An exception is represented by an instance of the class Throwable (a direct subclass of Object ) or one of its subclasses. Throwable and all its subclasses are, collectively, the exception classes . The classes Exception and Error are direct subclasses of Throwable : Exception is the superclass of all the exceptions from which ordinary programs may wish to recover. The class RuntimeException is a direct subclass of Exception . RuntimeException is the superclass of all the exceptions which may be thrown for many reasons during expression evaluation, but from which recovery may still be possible. RuntimeException and all its subclasses are, collectively, the run-time exception classes . Error is the superclass of all the exceptions from which ordinary programs are not ordinarily expected to recover. Error and all its subclasses are, collectively, the error classes . The unchecked exception classes are the run-time exception classes and the error classes. The checked exception classes are all exception classes other than the unchecked exception classes. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses. Programs can use the pre-existing exception classes of the Java SE Platform API in throw statements, or define additional exception classes as subclasses of Throwable or of any of its subclasses, as appropriate. To take advantage of compile-time checking for exception handlers ( §11.2 ), it is typical to define most new exception classes as checked exception classes, that is, as subclasses of Exception that are not subclasses of RuntimeException . The class Error is a separate subclass of Throwable , distinct from Exception in the class hierarchy, to allow programs to use the idiom \" } catch (Exception e) { \" ( §11.2.3 ) to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible. Note that a subclass of Throwable cannot be generic ( §8.1.2 ). 11.1.2. The Causes of Exceptions An exception is thrown for one of three reasons: A throw statement ( §14.18 ) was executed. An abnormal execution condition was synchronously detected by the Java Virtual Machine, namely: evaluation of an expression violates the normal semantics of the Java programming language ( §15.6 ), such as an integer divide by zero. an error occurs while loading, linking, or initializing part of the program ( §12.2 , §12.3 , §12.4 ); in this case, an instance of a subclass of LinkageError is thrown. an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMachineError is thrown. These exceptions are not thrown at an arbitrary point in the program, but rather at a point where they are specified as a possible result of an expression evaluation or statement execution. An asynchronous exception occurred ( §11.1.3 ). 11.1.3. Asynchronous Exceptions Most exceptions occur synchronously as a result of an action by the thread in which they occur, and at a point in the program that is specified to possibly result in such an exception. An asynchronous exception is, by contrast, an exception that can potentially occur at any point in the execution of a program. Asynchronous exceptions occur only as a result of: An invocation of the (deprecated) stop method of class Thread or ThreadGroup . The (deprecated) stop methods may be invoked by one thread to affect another thread or all the threads in a specified thread group. They are asynchronous because they may occur at any point in the execution of the other thread or threads. An internal error or resource limitation in the Java Virtual Machine that prevents it from implementing the semantics of the Java programming language. In this case, the asynchronous exception that is thrown is an instance of a subclass of VirtualMachineError . Note that StackOverflowError , a subclass of VirtualMachineError , may be thrown synchronously by method invocation ( §15.12.4.5 ) as well as asynchronously due to native method execution or Java Virtual Machine resource limitations. Similarly, OutOfMemoryError , another subclass of VirtualMachineError , may be thrown synchronously during class instance creation ( §15.9.4 , §12.5 ), array creation ( §15.10.2 , §10.6 ), class initialization ( §12.4.2 ), and boxing conversion ( §5.1.7 ), as well as asynchronously. The Java SE Platform permits a small but bounded amount of execution to occur before an asynchronous exception is thrown. Asynchronous exceptions are rare, but proper understanding of their semantics is necessary if high-quality machine code is to be generated. The delay noted above is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language. A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction. Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception. Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance. The paper Polling Efficiently on Stock Hardware by Marc Feeley, Proc. 1993 Conference on Functional Programming and Computer Architecture , Copenhagen, Denmark, pp. 179-187, is recommended as further reading.",
    "metadata": {
      "java_version": "17",
      "section_number": "11",
      "section_title": "Chapter 11. Exceptions",
      "chapter_title": "Chapter 11. Exceptions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-11.html",
    "section_name": "exceptions",
    "downloaded_at": "2025-05-27T13:20:19.794972"
  },
  "exceptions_java21": {
    "text": "11.1. The Kinds and Causes of Exceptions 11.1.1. The Kinds of Exceptions An exception is represented by an instance of the class Throwable (a direct subclass of Object ) or one of its subclasses. Throwable and all its subclasses are, collectively, the exception classes . The classes Exception and Error are direct subclasses of Throwable : Exception is the superclass of all the exceptions from which ordinary programs may wish to recover. The class RuntimeException is a direct subclass of Exception . RuntimeException is the superclass of all the exceptions which may be thrown for many reasons during expression evaluation, but from which recovery may still be possible. RuntimeException and all its subclasses are, collectively, the run-time exception classes . Error is the superclass of all the exceptions from which ordinary programs are not ordinarily expected to recover. Error and all its subclasses are, collectively, the error classes . The unchecked exception classes are the run-time exception classes and the error classes. The checked exception classes are all exception classes other than the unchecked exception classes. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses. Programs can use the pre-existing exception classes of the Java SE Platform API in throw statements, or define additional exception classes as subclasses of Throwable or of any of its subclasses, as appropriate. To take advantage of compile-time checking for exception handlers ( §11.2 ), it is typical to define most new exception classes as checked exception classes, that is, as subclasses of Exception that are not subclasses of RuntimeException . The class Error is a separate subclass of Throwable , distinct from Exception in the class hierarchy, to allow programs to use the idiom \" } catch (Exception e) { \" ( §11.2.3 ) to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible. Note that a subclass of Throwable cannot be generic ( §8.1.2 ). 11.1.2. The Causes of Exceptions An exception is thrown for one of four reasons: A throw statement ( §14.18 ) was executed. An enabled assert statement was executed, and evaluation of its boolean expression evaluated to false ( §14.10 ). An abnormal execution condition was synchronously detected by the Java Virtual Machine, namely: evaluation of an expression violates the normal semantics of the Java programming language ( §15.6 ), such as an integer divide by zero. an error occurs while loading, linking, or initializing part of the program ( §12.2 , §12.3 , §12.4 ); in this case, an instance of a subclass of LinkageError is thrown. an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMachineError is thrown. These exceptions are not thrown at an arbitrary point in the program, but rather at a point where they are specified as a possible result of an expression evaluation or statement execution. An asynchronous exception occurred ( §11.1.3 ). 11.1.3. Asynchronous Exceptions Most exceptions occur synchronously as a result of an action by the thread in which they occur, and at a point in the program that is specified to possibly result in such an exception. An asynchronous exception is, by contrast, an exception that can potentially occur at any point in the execution of a program. Asynchronous exceptions occur only as a result of an internal error or resource limitation in the Java Virtual Machine that prevents it from implementing the semantics of the Java programming language. The asynchronous exception that is thrown is an instance of a subclass of VirtualMachineError . Note that StackOverflowError , a subclass of VirtualMachineError , may be thrown synchronously by method invocation ( §15.12.4.5 ) as well as asynchronously due to native method execution or Java Virtual Machine resource limitations. Similarly, OutOfMemoryError , another subclass of VirtualMachineError , may be thrown synchronously during class instance creation ( §15.9.4 , §12.5 ), array creation ( §15.10.2 , §10.6 ), class initialization ( §12.4.2 ), and boxing conversion ( §5.1.7 ), as well as asynchronously. The Java SE Platform permits a small but bounded amount of execution to occur before an asynchronous exception is thrown. Asynchronous exceptions are rare, but proper understanding of their semantics is necessary if high-quality machine code is to be generated. The delay noted above is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language. A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction. Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception. Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance. The paper Polling Efficiently on Stock Hardware by Marc Feeley, Proc. 1993 Conference on Functional Programming and Computer Architecture , Copenhagen, Denmark, pp. 179-187, is recommended as further reading.",
    "metadata": {
      "java_version": "21",
      "section_number": "11",
      "section_title": "Chapter 11. Exceptions",
      "chapter_title": "Chapter 11. Exceptions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-11.html",
    "section_name": "exceptions",
    "downloaded_at": "2025-05-27T13:20:20.892864"
  },
  "exceptions_java24": {
    "text": "11.1. The Kinds and Causes of Exceptions 11.1.1. The Kinds of Exceptions An exception is represented by an instance of the class Throwable (a direct subclass of Object ) or one of its subclasses. Throwable and all its subclasses are, collectively, the exception classes . The classes Exception and Error are direct subclasses of Throwable : Exception is the superclass of all the exceptions from which ordinary programs may wish to recover. The class RuntimeException is a direct subclass of Exception . RuntimeException is the superclass of all the exceptions which may be thrown for many reasons during expression evaluation, but from which recovery may still be possible. RuntimeException and all its subclasses are, collectively, the run-time exception classes . Error is the superclass of all the exceptions from which ordinary programs are not ordinarily expected to recover. Error and all its subclasses are, collectively, the error classes . The unchecked exception classes are the run-time exception classes and the error classes. The checked exception classes are all exception classes other than the unchecked exception classes. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses. Programs can use the pre-existing exception classes of the Java SE Platform API in throw statements, or define additional exception classes as subclasses of Throwable or of any of its subclasses, as appropriate. To take advantage of compile-time checking for exception handlers ( §11.2 ), it is typical to define most new exception classes as checked exception classes, that is, as subclasses of Exception that are not subclasses of RuntimeException . The class Error is a separate subclass of Throwable , distinct from Exception in the class hierarchy, to allow programs to use the idiom \" } catch (Exception e) { \" ( §11.2.3 ) to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible. Note that a subclass of Throwable cannot be generic ( §8.1.2 ). 11.1.2. The Causes of Exceptions An exception is thrown for one of four reasons: A throw statement ( §14.18 ) was executed. An enabled assert statement was executed, and evaluation of its boolean expression evaluated to false ( §14.10 ). An abnormal execution condition was synchronously detected by the Java Virtual Machine, namely: evaluation of an expression violates the normal semantics of the Java programming language ( §15.6 ), such as an integer divide by zero. an error occurs while loading, linking, or initializing part of the program ( §12.2 , §12.3 , §12.4 ); in this case, an instance of a subclass of LinkageError is thrown. an internal error or resource limitation prevents the Java Virtual Machine from implementing the semantics of the Java programming language; in this case, an instance of a subclass of VirtualMachineError is thrown. These exceptions are not thrown at an arbitrary point in the program, but rather at a point where they are specified as a possible result of an expression evaluation or statement execution. An asynchronous exception occurred ( §11.1.3 ). 11.1.3. Asynchronous Exceptions Most exceptions occur synchronously as a result of an action by the thread in which they occur, and at a point in the program that is specified to possibly result in such an exception. An asynchronous exception is, by contrast, an exception that can potentially occur at any point in the execution of a program. Asynchronous exceptions occur only as a result of an internal error or resource limitation in the Java Virtual Machine that prevents it from implementing the semantics of the Java programming language. The asynchronous exception that is thrown is an instance of a subclass of VirtualMachineError . Note that StackOverflowError , a subclass of VirtualMachineError , may be thrown synchronously by method invocation ( §15.12.4.5 ) as well as asynchronously due to native method execution or Java Virtual Machine resource limitations. Similarly, OutOfMemoryError , another subclass of VirtualMachineError , may be thrown synchronously during class instance creation ( §15.9.4 , §12.5 ), array creation ( §15.10.2 , §10.6 ), class initialization ( §12.4.2 ), and boxing conversion ( §5.1.7 ), as well as asynchronously. The Java SE Platform permits a small but bounded amount of execution to occur before an asynchronous exception is thrown. Asynchronous exceptions are rare, but proper understanding of their semantics is necessary if high-quality machine code is to be generated. The delay noted above is permitted to allow optimized code to detect and throw these exceptions at points where it is practical to handle them while obeying the semantics of the Java programming language. A simple implementation might poll for asynchronous exceptions at the point of each control transfer instruction. Since a program has a finite size, this provides a bound on the total delay in detecting an asynchronous exception. Since no asynchronous exception will occur between control transfers, the code generator has some flexibility to reorder computation between control transfers for greater performance. The paper Polling Efficiently on Stock Hardware by Marc Feeley, Proc. 1993 Conference on Functional Programming and Computer Architecture , Copenhagen, Denmark, pp. 179-187, is recommended as further reading.",
    "metadata": {
      "java_version": "24",
      "section_number": "11",
      "section_title": "Chapter 11. Exceptions",
      "chapter_title": "Chapter 11. Exceptions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-11.html",
    "section_name": "exceptions",
    "downloaded_at": "2025-05-27T13:20:22.004923"
  },
  "interfaces_java8": {
    "text": "9.1. Interface Declarations An interface declaration specifies a new named reference type. There are two kinds of interface declarations - normal interface declarations and annotation type declarations ( §9.6 ). InterfaceDeclaration: NormalInterfaceDeclaration AnnotationTypeDeclaration NormalInterfaceDeclaration: { InterfaceModifier } interface Identifier [ TypeParameters ] [ ExtendsInterfaces ] InterfaceBody The Identifier in an interface declaration specifies the name of the interface. It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of an interface declaration is specified in §6.3 and §6.4 . 9.1.1. Interface Modifiers An interface declaration may include interface modifiers . InterfaceModifier: (one of) Annotation public protected private abstract static strictfp The rules for annotation modifiers on an interface declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains to every kind of interface declaration. The access modifiers protected and private pertain only to member interfaces whose declarations are directly enclosed by a class declaration ( §8.5.1 ). The modifier static pertains only to member interfaces ( §8.5.1 , §9.5 ), not to top level interfaces ( §7.6 ). It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration. If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier . 9.1.1.1. abstract Interfaces Every interface is implicitly abstract . This modifier is obsolete and should not be used in new programs. 9.1.1.2. strictfp Interfaces The effect of the strictfp modifier is to make all float or double expressions within the interface declaration be explicitly FP-strict ( §15.4 ). This implies that all methods declared in the interface, and all nested types declared in the interface, are implicitly strictfp . 9.1.2. Generic Interfaces and Type Parameters An interface is generic if it declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the interface. The type parameter section follows the interface name and is delimited by angle brackets. The following productions from §8.1.2 and §4.4 are shown here for convenience: TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } TypeParameter: { TypeParameterModifier } Identifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules for annotation modifiers on a type parameter declaration are specified in §9.7.4 and §9.7.5 . In an interface's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself. The scope and shadowing of an interface's type parameter is specified in §6.3 . It is a compile-time error to refer to a type parameter of an interface I anywhere in the declaration of a field or type member of I . A generic interface declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time. 9.1.3. Superinterfaces and Subinterfaces If an extends clause is provided, then the interface being declared extends each of the other named interfaces and therefore inherits the member types, methods, and constants of each of the other named interfaces. These other named interfaces are the direct superinterfaces of the interface being declared. Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends . ExtendsInterfaces: extends InterfaceTypeList The following production from §8.1.5 is shown here for convenience: InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType in the extends clause of an interface declaration must name an accessible interface type ( §6.6 ), or a compile-time error occurs. If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. Given a (possibly generic) interface declaration I < F 1 ,..., F n > ( n ≥ 0), the direct superinterfaces of the interface type I < F 1 ,..., F n > are the types given in the extends clause of the declaration of I , if an extends clause is present. Given a generic interface declaration I < F 1 ,..., F n > ( n > 0), the direct superinterfaces of the parameterized interface type I < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, are all types J < U 1 θ ,..., U k θ > , where J < U 1 ,..., U k > is a direct superinterface of I < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . The superinterface relationship is the transitive closure of the direct superinterface relationship. An interface K is a superinterface of interface I if either of the following is true: K is a direct superinterface of I . There exists an interface J such that K is a superinterface of J , and J is a superinterface of I , applying this definition recursively. Interface I is said to be a subinterface of interface K whenever K is a superinterface of I . While every class is an extension of class Object , there is no single interface of which all interfaces are extensions. An interface I directly depends on a type T if T is mentioned in the extends clause of I either as a superinterface or as a qualifier in the fully qualified form of a superinterface name. An interface I depends on a reference type T if any of the following is true: I directly depends on T . I directly depends on a class C that depends on T ( §8.1.5 ). I directly depends on an interface J that depends on T (using this definition recursively). It is a compile-time error if an interface depends on itself. If circularly declared interfaces are detected at run time, as interfaces are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). 9.1.4. Interface Body and Member Declarations The body of an interface may declare members of the interface, that is, fields ( §9.3 ), methods ( §9.4 ), classes ( §9.5 ), and interfaces ( §9.5 ). InterfaceBody: { { InterfaceMemberDeclaration } } InterfaceMemberDeclaration: ConstantDeclaration InterfaceMethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope of a declaration of a member m declared in or inherited by an interface type I is specified in §6.3 .",
    "metadata": {
      "java_version": "8",
      "section_number": "9",
      "section_title": "Chapter 9. Interfaces",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html",
    "section_name": "interfaces",
    "downloaded_at": "2025-05-27T13:20:23.340868"
  },
  "interfaces_java11": {
    "text": "9.1. Interface Declarations An interface declaration specifies a new named reference type. There are two kinds of interface declarations - normal interface declarations and annotation type declarations ( §9.6 ). InterfaceDeclaration: NormalInterfaceDeclaration AnnotationTypeDeclaration NormalInterfaceDeclaration: { InterfaceModifier } interface TypeIdentifier [ TypeParameters ] [ ExtendsInterfaces ] InterfaceBody The TypeIdentifier in an interface declaration specifies the name of the interface. It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of an interface declaration is specified in §6.3 and §6.4 . 9.1.1. Interface Modifiers An interface declaration may include interface modifiers . InterfaceModifier: (one of) Annotation public protected private abstract static strictfp The rules for annotation modifiers on an interface declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains to every kind of interface declaration. The access modifiers protected and private pertain only to member interfaces whose declarations are directly enclosed by a class declaration ( §8.5.1 ). The modifier static pertains only to member interfaces ( §8.5.1 , §9.5 ), not to top level interfaces ( §7.6 ). It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration, or if a interface declaration has more than one of the access modifiers public , protected , and private ( §6.6 ). If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier . 9.1.1.1. abstract Interfaces Every interface is implicitly abstract . This modifier is obsolete and should not be used in new programs. 9.1.1.2. strictfp Interfaces The effect of the strictfp modifier is to make all float or double expressions within the interface declaration be explicitly FP-strict ( §15.4 ). This implies that all methods declared in the interface, and all nested types declared in the interface, are implicitly strictfp . 9.1.2. Generic Interfaces and Type Parameters An interface is generic if it declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the interface. The type parameter section follows the interface name and is delimited by angle brackets. The following productions from §8.1.2 and §4.4 are shown here for convenience: TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules for annotation modifiers on a type parameter declaration are specified in §9.7.4 and §9.7.5 . In an interface's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself. The scope and shadowing of an interface's type parameter is specified in §6.3 . It is a compile-time error to refer to a type parameter of a generic interface I anywhere in the declaration of a static member of I ( §9.3 , §9.4 , §9.5 ). A generic interface declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time. 9.1.3. Superinterfaces and Subinterfaces If an extends clause is provided, then the interface being declared extends each of the other named interfaces and therefore inherits the member types, instance methods, and constants of each of the other named interfaces. These other named interfaces are the direct superinterfaces of the interface being declared. Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends . ExtendsInterfaces: extends InterfaceTypeList The following production from §8.1.5 is shown here for convenience: InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType in the extends clause of an interface declaration must name an accessible interface type ( §6.6 ), or a compile-time error occurs. If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. Given a (possibly generic) interface declaration I < F 1 ,..., F n > ( n ≥ 0), the direct superinterfaces of the interface type I < F 1 ,..., F n > are the types given in the extends clause of the declaration of I , if an extends clause is present. Given a generic interface declaration I < F 1 ,..., F n > ( n > 0), the direct superinterfaces of the parameterized interface type I < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, are all types J < U 1 θ ,..., U k θ > , where J < U 1 ,..., U k > is a direct superinterface of I < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . The superinterface relationship is the transitive closure of the direct superinterface relationship. An interface K is a superinterface of interface I if either of the following is true: K is a direct superinterface of I . There exists an interface J such that K is a superinterface of J , and J is a superinterface of I , applying this definition recursively. Interface I is said to be a subinterface of interface K whenever K is a superinterface of I . While every class is an extension of class Object , there is no single interface of which all interfaces are extensions. An interface I directly depends on a type T if T is mentioned in the extends clause of I either as a superinterface or as a qualifier in the fully qualified form of a superinterface name. An interface I depends on a reference type T if any of the following is true: I directly depends on T . I directly depends on a class C that depends on T ( §8.1.5 ). I directly depends on an interface J that depends on T (using this definition recursively). It is a compile-time error if an interface depends on itself. If circularly declared interfaces are detected at run time, as interfaces are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). 9.1.4. Interface Body and Member Declarations The body of an interface may declare members of the interface, that is, fields ( §9.3 ), methods ( §9.4 ), classes ( §9.5 ), and interfaces ( §9.5 ). InterfaceBody: { { InterfaceMemberDeclaration } } InterfaceMemberDeclaration: ConstantDeclaration InterfaceMethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope of a declaration of a member m declared in or inherited by an interface type I is specified in §6.3 .",
    "metadata": {
      "java_version": "11",
      "section_number": "9",
      "section_title": "Chapter 9. Interfaces",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html",
    "section_name": "interfaces",
    "downloaded_at": "2025-05-27T13:20:24.723968"
  },
  "interfaces_java17": {
    "text": "9.1. Interface Declarations An interface declaration specifies an interface. There are two kinds of interface declarations: normal interface declarations and annotation interface declarations ( §9.6 ). InterfaceDeclaration: NormalInterfaceDeclaration AnnotationInterfaceDeclaration NormalInterfaceDeclaration: { InterfaceModifier } interface TypeIdentifier [ TypeParameters ] [ InterfaceExtends ] [ InterfacePermits ] InterfaceBody The TypeIdentifier in an interface declaration specifies the name of the interface. It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of an interface declaration is specified in §6.3 and §6.4.1 . 9.1.1. Interface Modifiers An interface declaration may include interface modifiers . InterfaceModifier: (one of) Annotation public protected private abstract static sealed non-sealed strictfp The rules concerning annotation modifiers for an interface declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level interfaces ( §7.6 ) and member interfaces ( §8.5 , §9.5 ), not to local interfaces ( §14.3 ). The access modifiers protected and private pertain only to member interfaces. The modifier static pertains only to member interfaces and local interfaces. It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration, or if a interface declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if an interface declaration has more than one of the modifiers sealed and non-sealed . If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier . 9.1.1.1. abstract Interfaces Every interface is implicitly abstract . This modifier is obsolete and should not be used in new code. 9.1.1.2. strictfp Interfaces The strictfp modifier on an interface declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 9.1.1.3. static Interfaces A nested interface is implicitly static . That is, every member interface and local interface is static . It is permitted for the declaration of a member interface to redundantly specify the static modifier ( §9.5 ), but it is not permitted for the declaration of a local interface ( §14.3 ). Because a nested interface is static , it has no immediately enclosing instance ( §8.1.3 ). References from a nested interface to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods in lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , §15.12.3 ). 9.1.1.4. sealed and non-sealed Interfaces An interface can be declared sealed if all its direct subclasses and direct subinterfaces are known when the interface is declared ( §9.1.4 ), and no other direct subclasses or direct subinterfaces are desired or required. It is useful to recall that a class is said to be a direct subclass of its direct superinterfaces ( §8.1.5 ). An interface is freely extensible if none of its direct superinterfaces are sealed ( §9.1.3 ), and it is not sealed itself. An interface that has a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if an interface has a sealed direct superinterface and is not declared sealed or non-sealed . It is a compile-time error if an interface is declared non-sealed but has no sealed direct superinterface. 9.1.2. Generic Interfaces and Type Parameters An interface is generic if the interface declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the interface. The type parameter section follows the interface name and is delimited by angle brackets. The following productions from §8.1.2 and §4.4 are shown here for convenience: TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In an interface's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself. The scope and shadowing of an interface's type parameter is specified in §6.3 and §6.4.1 . References to an interface's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic interface declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time. 9.1.3. Superinterfaces and Subinterfaces If an extends clause is provided, then the interface being declared extends each of the specified interface types and therefore inherits the member classes, member interfaces, instance methods, and static fields of each of those interface types. The specified interface types are the direct superinterface types of the interface being declared. Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends . InterfaceExtends: extends InterfaceTypeList The following production from §8.1.5 is shown here for convenience: InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType in the extends clause of an interface declaration must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the interface being declared is not a permitted direct subinterface of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. One interface is a direct superinterface of another interface if the first interface is named by one of the direct superinterface types of the second interface. The superinterface relationship is the transitive closure of the direct superinterface relationship. An interface I is a superinterface of interface K if either of the following is true: I is a direct superinterface of K . Where J is a direct superinterface of K , I is a superinterface of J , applying this definition recursively. An interface is said to be a direct subinterface of its direct superinterface, and a subinterface of each of its superinterfaces. While every class is an extension of class Object , there is no single interface of which all interfaces are extensions. An interface I directly depends on a class or interface A if A is mentioned in the extends clause of I either as a superinterface or as a qualifier in the fully qualified form of a superinterface name. An interface I depends on a class or interface A if any of the following is true: I directly depends on A . I directly depends on a class C that depends on A ( §8.1.5 ). I directly depends on an interface J that depends on A , applying this definition recursively. It is a compile-time error if an interface depends on itself. If circularly declared interfaces are detected at run time, as interfaces are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). 9.1.4. Permitted Direct Subclasses and Subinterfaces The optional permits clause in a normal interface declaration specifies all the classes and interfaces intended as direct subclasses and direct subinterfaces of the interface being declared ( §9.1.1.4 ). InterfacePermits: permits TypeName { , TypeName } It is a compile-time error if an interface declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class or interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class or interface is specified more than once in a permits clause. This is true even if the class or interface is named in different ways. The canonical name of a class or interface does not need to be used in a permits clause, but a permits clause can only specify a class or interface once. For example, the following program fails to compile: package p; sealed interface I permits C, D, p.C {} // error non-sealed class C implements I {} non-sealed class D implements I {} If a sealed interface I is associated with a named module ( §7.3 ), then every class or interface specified in the permits clause of I 's declaration must be associated with the same module as I , or a compile-time error occurs. If a sealed interface I is associated with an unnamed module ( §7.7.5 ), then every class or interface specified in the permits clause of I 's declaration must belong to the same package as I , or a compile-time error occurs. A sealed interface and its direct subclasses and direct subinterfaces need to refer to each other in a circular fashion, in permits , implements , and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes and interfaces in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed interface hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed interface I has a permits clause, then the permitted direct subclasses and subinterfaces of I are the classes and interfaces specified by the permits clause. Every permitted direct subclass and subinterface specified by the permits clause must be a direct subclass of I ( §8.1.5 ) or a direct subinterface of I ( §9.1.3 ), or a compile-time error occurs. If the declaration of a sealed interface I lacks a permits clause, then the permitted direct subclasses and subinterfaces of I are those classes and interfaces declared in the same compilation unit as I ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superinterfaces include I . That is, the permitted direct subclasses and subinterfaces are inferred as the classes and interfaces in the same compilation unit that specify I as a direct superinterface. The requirement for a canonical name means that no local classes, local interfaces, or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed interface I lacks a permits clause and I has no permitted direct subclasses or subinterfaces. 9.1.5. Interface Body and Member Declarations An interface body may contain declarations of members of the interface, that is, fields ( §9.3 ), methods ( §9.4 ), classes, and interfaces ( §9.5 ). InterfaceBody: { { InterfaceMemberDeclaration } } InterfaceMemberDeclaration: ConstantDeclaration InterfaceMethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope of a declaration of a member m declared in or inherited by an interface I is specified in §6.3 .",
    "metadata": {
      "java_version": "17",
      "section_number": "9",
      "section_title": "Chapter 9. Interfaces",
      "chapter_title": "Chapter 9. Interfaces"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-9.html",
    "section_name": "interfaces",
    "downloaded_at": "2025-05-27T13:20:26.802131"
  },
  "interfaces_java21": {
    "text": "9.1. Interface Declarations An interface declaration specifies an interface. There are two kinds of interface declarations: normal interface declarations and annotation interface declarations ( §9.6 ). InterfaceDeclaration: NormalInterfaceDeclaration AnnotationInterfaceDeclaration NormalInterfaceDeclaration: { InterfaceModifier } interface TypeIdentifier [ TypeParameters ] [ InterfaceExtends ] [ InterfacePermits ] InterfaceBody The TypeIdentifier in an interface declaration specifies the name of the interface. It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of an interface declaration is specified in §6.3 and §6.4.1 . 9.1.1. Interface Modifiers An interface declaration may include interface modifiers . InterfaceModifier: (one of) Annotation public protected private abstract static sealed non-sealed strictfp The rules concerning annotation modifiers for an interface declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level interfaces ( §7.6 ) and member interfaces ( §8.5 , §9.5 ), not to local interfaces ( §14.3 ). The access modifiers protected and private pertain only to member interfaces. The modifier static pertains only to member interfaces and local interfaces. It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration, or if a interface declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if an interface declaration has more than one of the modifiers sealed and non-sealed . If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier . 9.1.1.1. abstract Interfaces Every interface is implicitly abstract . This modifier is obsolete and should not be used in new code. 9.1.1.2. strictfp Interfaces The strictfp modifier on an interface declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 9.1.1.3. static Interfaces A nested interface is implicitly static . That is, every member interface and local interface is static . It is permitted for the declaration of a member interface to redundantly specify the static modifier ( §9.5 ), but it is not permitted for the declaration of a local interface ( §14.3 ). Because a nested interface is static , it has no immediately enclosing instance ( §8.1.3 ). References from a nested interface to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods in lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , §15.12.3 ). 9.1.1.4. sealed and non-sealed Interfaces An interface can be declared sealed if all its direct subclasses and direct subinterfaces are known when the interface is declared ( §9.1.4 ), and no other direct subclasses or direct subinterfaces are desired or required. It is useful to recall that a class is said to be a direct subclass of its direct superinterfaces ( §8.1.5 ). An interface is freely extensible if none of its direct superinterfaces are sealed ( §9.1.3 ), and it is not sealed itself. An interface that has a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if an interface has a sealed direct superinterface and is not declared sealed or non-sealed . It is a compile-time error if an interface is declared non-sealed but has no sealed direct superinterface. 9.1.2. Generic Interfaces and Type Parameters An interface is generic if the interface declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the interface. The type parameter section follows the interface name and is delimited by angle brackets. The following productions from §8.1.2 and §4.4 are shown here for convenience: TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In an interface's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself. The scope and shadowing of an interface's type parameter is specified in §6.3 and §6.4.1 . References to an interface's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic interface declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time. 9.1.3. Superinterfaces and Subinterfaces If an extends clause is provided, then the interface being declared extends each of the specified interface types and therefore inherits the member classes, member interfaces, instance methods, and static fields of each of those interface types. The specified interface types are the direct superinterface types of the interface being declared. Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends . InterfaceExtends: extends InterfaceTypeList The following production from §8.1.5 is shown here for convenience: InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType in the extends clause of an interface declaration must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the interface being declared is not a permitted direct subinterface of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. One interface is a direct superinterface of another interface if the first interface is named by one of the direct superinterface types of the second interface. The superinterface relationship is the transitive closure of the direct superinterface relationship. An interface I is a superinterface of interface K if either of the following is true: I is a direct superinterface of K . Where J is a direct superinterface of K , I is a superinterface of J , applying this definition recursively. An interface is said to be a direct subinterface of its direct superinterface, and a subinterface of each of its superinterfaces. While every class is an extension of class Object , there is no single interface of which all interfaces are extensions. An interface I directly depends on a class or interface A if A is mentioned in the extends clause of I either as a superinterface or as a qualifier in the fully qualified form of a superinterface name. An interface I depends on a class or interface A if any of the following is true: I directly depends on A . I directly depends on a class C that depends on A ( §8.1.5 ). I directly depends on an interface J that depends on A , applying this definition recursively. It is a compile-time error if an interface depends on itself. If circularly declared interfaces are detected at run time, as interfaces are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). 9.1.4. Permitted Direct Subclasses and Subinterfaces The optional permits clause in a normal interface declaration specifies all the classes and interfaces intended as direct subclasses and direct subinterfaces of the interface being declared ( §9.1.1.4 ). InterfacePermits: permits TypeName { , TypeName } It is a compile-time error if an interface declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class or interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class or interface is specified more than once in a permits clause. This is true even if the class or interface is named in different ways. The canonical name of a class or interface does not need to be used in a permits clause, but a permits clause can only specify a class or interface once. For example, the following program fails to compile: package p; sealed interface I permits C, D, p.C {} // error non-sealed class C implements I {} non-sealed class D implements I {} If a sealed interface I is associated with a named module ( §7.3 ), then every class or interface specified in the permits clause of I 's declaration must be associated with the same module as I , or a compile-time error occurs. If a sealed interface I is associated with an unnamed module ( §7.7.5 ), then every class or interface specified in the permits clause of I 's declaration must belong to the same package as I , or a compile-time error occurs. A sealed interface and its direct subclasses and direct subinterfaces need to refer to each other in a circular fashion, in permits , implements , and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes and interfaces in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed interface hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed interface I has a permits clause, then the permitted direct subclasses and subinterfaces of I are the classes and interfaces specified by the permits clause. Every permitted direct subclass and subinterface specified by the permits clause must be a direct subclass of I ( §8.1.5 ) or a direct subinterface of I ( §9.1.3 ), or a compile-time error occurs. If the declaration of a sealed interface I lacks a permits clause, then the permitted direct subclasses and subinterfaces of I are those classes and interfaces declared in the same compilation unit as I ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superinterfaces include I . That is, the permitted direct subclasses and subinterfaces are inferred as the classes and interfaces in the same compilation unit that specify I as a direct superinterface. The requirement for a canonical name means that no local classes, local interfaces, or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed interface I lacks a permits clause and I has no permitted direct subclasses or subinterfaces. 9.1.5. Interface Body and Member Declarations An interface body may contain declarations of members of the interface, that is, fields ( §9.3 ), methods ( §9.4 ), classes, and interfaces ( §9.5 ). InterfaceBody: { { InterfaceMemberDeclaration } } InterfaceMemberDeclaration: ConstantDeclaration InterfaceMethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope of a declaration of a member m declared in or inherited by an interface I is specified in §6.3 .",
    "metadata": {
      "java_version": "21",
      "section_number": "9",
      "section_title": "Chapter 9. Interfaces",
      "chapter_title": "Chapter 9. Interfaces"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html",
    "section_name": "interfaces",
    "downloaded_at": "2025-05-27T13:20:28.222438"
  },
  "interfaces_java24": {
    "text": "9.1. Interface Declarations An interface declaration specifies an interface. There are two kinds of interface declarations: normal interface declarations and annotation interface declarations ( §9.6 ). InterfaceDeclaration: NormalInterfaceDeclaration AnnotationInterfaceDeclaration NormalInterfaceDeclaration: { InterfaceModifier } interface TypeIdentifier [ TypeParameters ] [ InterfaceExtends ] [ InterfacePermits ] InterfaceBody The TypeIdentifier in an interface declaration specifies the name of the interface. It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of an interface declaration is specified in §6.3 and §6.4.1 . 9.1.1. Interface Modifiers An interface declaration may include interface modifiers . InterfaceModifier: (one of) Annotation public protected private abstract static sealed non-sealed strictfp The rules concerning annotation modifiers for an interface declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level interfaces ( §7.6 ) and member interfaces ( §8.5 , §9.5 ), not to local interfaces ( §14.3 ). The access modifiers protected and private pertain only to member interfaces. The modifier static pertains only to member interfaces and local interfaces. It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration, or if a interface declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if an interface declaration has more than one of the modifiers sealed and non-sealed . If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier . 9.1.1.1. abstract Interfaces Every interface is implicitly abstract . This modifier is obsolete and should not be used in new code. 9.1.1.2. strictfp Interfaces The strictfp modifier on an interface declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 9.1.1.3. static Interfaces A nested interface is implicitly static . That is, every member interface and local interface is static . It is permitted for the declaration of a member interface to redundantly specify the static modifier ( §9.5 ), but it is not permitted for the declaration of a local interface ( §14.3 ). Because a nested interface is static , it has no immediately enclosing instance ( §8.1.3 ). References from a nested interface to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods in lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , §15.12.3 ). 9.1.1.4. sealed and non-sealed Interfaces An interface can be declared sealed if all its direct subclasses and direct subinterfaces are known when the interface is declared ( §9.1.4 ), and no other direct subclasses or direct subinterfaces are desired or required. It is useful to recall that a class is said to be a direct subclass of its direct superinterfaces ( §8.1.5 ). An interface is freely extensible if none of its direct superinterfaces are sealed ( §9.1.3 ), and it is not sealed itself. An interface that has a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if an interface has a sealed direct superinterface and is not declared sealed or non-sealed . It is a compile-time error if an interface is declared non-sealed but has no sealed direct superinterface. 9.1.2. Generic Interfaces and Type Parameters An interface is generic if the interface declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the interface. The type parameter section follows the interface name and is delimited by angle brackets. The following productions from §8.1.2 and §4.4 are shown here for convenience: TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In an interface's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself. The scope and shadowing of an interface's type parameter is specified in §6.3 and §6.4.1 . References to an interface's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic interface declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time. 9.1.3. Superinterfaces and Subinterfaces If an extends clause is provided, then the interface being declared extends each of the specified interface types and therefore inherits the member classes, member interfaces, instance methods, and static fields of each of those interface types. The specified interface types are the direct superinterface types of the interface being declared. Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends . InterfaceExtends: extends InterfaceTypeList The following production from §8.1.5 is shown here for convenience: InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType in the extends clause of an interface declaration must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the interface being declared is not a permitted direct subinterface of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. One interface is a direct superinterface of another interface if the first interface is named by one of the direct superinterface types of the second interface. The superinterface relationship is the transitive closure of the direct superinterface relationship. An interface I is a superinterface of interface K if either of the following is true: I is a direct superinterface of K . Where J is a direct superinterface of K , I is a superinterface of J , applying this definition recursively. An interface is said to be a direct subinterface of its direct superinterface, and a subinterface of each of its superinterfaces. While every class is an extension of class Object , there is no single interface of which all interfaces are extensions. An interface I directly depends on a class or interface A if A is mentioned in the extends clause of I either as a superinterface or as a qualifier in the fully qualified form of a superinterface name. An interface I depends on a class or interface A if any of the following is true: I directly depends on A . I directly depends on a class C that depends on A ( §8.1.5 ). I directly depends on an interface J that depends on A , applying this definition recursively. It is a compile-time error if an interface depends on itself. If circularly declared interfaces are detected at run time, as interfaces are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). 9.1.4. Permitted Direct Subclasses and Subinterfaces The optional permits clause in a normal interface declaration specifies all the classes and interfaces intended as direct subclasses and direct subinterfaces of the interface being declared ( §9.1.1.4 ). InterfacePermits: permits TypeName { , TypeName } It is a compile-time error if an interface declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class or interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class or interface is specified more than once in a permits clause. This is true even if the class or interface is named in different ways. The canonical name of a class or interface does not need to be used in a permits clause, but a permits clause can only specify a class or interface once. For example, the following program fails to compile: package p; sealed interface I permits C, D, p.C {} // error non-sealed class C implements I {} non-sealed class D implements I {} If a sealed interface I is associated with a named module ( §7.3 ), then every class or interface specified in the permits clause of I 's declaration must be associated with the same module as I , or a compile-time error occurs. If a sealed interface I is associated with an unnamed module ( §7.7.5 ), then every class or interface specified in the permits clause of I 's declaration must belong to the same package as I , or a compile-time error occurs. A sealed interface and its direct subclasses and direct subinterfaces need to refer to each other in a circular fashion, in permits , implements , and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes and interfaces in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed interface hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed interface I has a permits clause, then the permitted direct subclasses and subinterfaces of I are the classes and interfaces specified by the permits clause. Every permitted direct subclass and subinterface specified by the permits clause must be a direct subclass of I ( §8.1.5 ) or a direct subinterface of I ( §9.1.3 ), or a compile-time error occurs. If the declaration of a sealed interface I lacks a permits clause, then the permitted direct subclasses and subinterfaces of I are those classes and interfaces declared in the same compilation unit as I ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superinterfaces include I . That is, the permitted direct subclasses and subinterfaces are inferred as the classes and interfaces in the same compilation unit that specify I as a direct superinterface. The requirement for a canonical name means that no local classes, local interfaces, or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed interface I lacks a permits clause and I has no permitted direct subclasses or subinterfaces. 9.1.5. Interface Body and Member Declarations An interface body may contain declarations of members of the interface, that is, fields ( §9.3 ), methods ( §9.4 ), classes, and interfaces ( §9.5 ). InterfaceBody: { { InterfaceMemberDeclaration } } InterfaceMemberDeclaration: ConstantDeclaration InterfaceMethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope of a declaration of a member m declared in or inherited by an interface I is specified in §6.3 .",
    "metadata": {
      "java_version": "24",
      "section_number": "9",
      "section_title": "Chapter 9. Interfaces",
      "chapter_title": "Chapter 9. Interfaces"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-9.html",
    "section_name": "interfaces",
    "downloaded_at": "2025-05-27T13:20:29.659648"
  },
  "abstract_methods_java8": {
    "text": "8.1. Class Declarations A class declaration specifies a new named reference type. There are two kinds of class declarations: normal class declarations and enum declarations . ClassDeclaration: NormalClassDeclaration EnumDeclaration NormalClassDeclaration: { ClassModifier } class Identifier [ TypeParameters ] [ Superclass ] [ Superinterfaces ] ClassBody The rules in this section apply to all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to class modifiers, inner classes, and superclasses; these rules are stated in §8.9 . The Identifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final strictfp The rules for annotation modifiers on a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes within a directly enclosing class declaration ( §8.5 ). The modifier static pertains only to member classes ( §8.5.1 ), not to top level or local or anonymous classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration. If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. final Classes A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if the name of a final class appears in the extends clause ( §8.1.4 ) of another class declaration; this implies that a final class cannot have any subclasses. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). 8.1.1.3. strictfp Classes The effect of the strictfp modifier is to make all float or double expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict ( §15.4 ). This implies that all methods declared in the class, and all nested types declared in the class, are implicitly strictfp . 8.1.2. Generic Classes and Type Parameters A class is generic if it declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } Identifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules for annotation modifiers on a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. It is a compile-time error to refer to a type parameter of a generic class C in any of the following: the declaration of a static member of C ( §8.3.1.1 , §8.4.3.2 , §8.5.1 ). the declaration of a static member of any type declaration nested within C . a static initializer of C ( §8.7 ), or a static initializer of any class declaration nested within C . Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly declared static . An inner class may be a non- static member class ( §8.5 ), a local class ( §14.3 ), or an anonymous class ( §15.9.5 ). A member class of an interface is implicitly static ( §9.5 ) so is never considered to be an inner class. It is a compile-time error if an inner class declares a static initializer ( §8.7 ). It is a compile-time error if an inner class declares a member that is explicitly or implicitly static , unless the member is a constant variable ( §4.12.4 ). An inner class may inherit static members that are not constant variables even though it cannot declare them. A nested class that is not an inner class may declare static members freely, in accordance with the usual rules of the Java programming language. Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static final int x = 3; // OK: constant variable static int y = 4; // Compile-time error: an inner class } static class NestedButNotInner{ static int z = 5; // OK: not an inner class } interface NeverInner {} // Interfaces are never inner } A statement or expression occurs in a static context if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement ( §8.8.7.1 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing type declaration of C and the declaration of C does not occur in a static context. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing type declaration of an inner class to be an interface. This only occurs if the class is declared in a default method body ( §9.4 ). Specifically, it occurs if an anonymous or local class is declared in a default method body, or a member class is declared in the body of an anonymous class that is declared in a default method body. A class or interface O is the zeroth lexically enclosing type declaration of itself . A class O is the n'th lexically enclosing type declaration of a class C if it is the immediately enclosing type declaration of the n-1 'th lexically enclosing type declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner class I whose declaration occurs in a static context has no lexically enclosing instances. However, if I is immediately declared within a static method or static initializer then I does have an enclosing block , which is the innermost block statement lexically enclosing the declaration of I . For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing type declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared final or be effectively final ( §4.12.4 ), or a compile-time error occurs where the use is attempted. Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing type declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are marked final ). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing type declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing type declaration, the instance variable must be defined with respect to an enclosing instance of that declared type. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass of the current class. Superclass: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass. The ClassType must name an accessible class type ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum or any invocation of Enum ( §8.9 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superclass of the class type C < F 1 ,..., F n > is the type given in the extends clause of the declaration of C if an extends clause is present, or Object otherwise. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superclass of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, is D < U 1 θ ,..., U k θ > , where D < U 1 ,..., U k > is the direct superclass of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . A class is said to be a direct subclass of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived. The subclass relationship is the transitive closure of the direct subclass relationship. A class A is a subclass of class C if either of the following is true: A is the direct subclass of C There exists a class B such that A is a subclass of B , and B is a subclass of C , applying this definition recursively. Class C is said to be a superclass of class A whenever A is a subclass of C . Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a reference type T if any of the following is true: C directly depends on T . C directly depends on an interface I that depends ( §9.1.3 ) on T . C directly depends on a class D that depends on T (using this definition recursively). It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration lists the names of interfaces that are direct superinterfaces of the class being declared. Superinterfaces: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface type ( §6.6 ), or a compile-time error occurs. If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is mentioned as a direct superinterface more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superinterfaces of the class type C < F 1 ,..., F n > are the types given in the implements clause of the declaration of C , if an implements clause is present. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superinterfaces of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, are all types I < U 1 θ ,..., U k θ > , where I < U 1 ,..., U k > is a direct superinterface of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . An interface type I is a superinterface of class type C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to implement all its superinterfaces. A class may not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface ( §9.1.2 ), or a subtype of a parameterization of a generic interface and a raw type naming that same generic interface, or a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-3. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes ( §8.5 ), and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class type C is specified in §6.3 and §6.4 . If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows ( §6.4.1 ) the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "8",
      "section_number": "8.4.3",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.3",
    "section_name": "abstract_methods",
    "downloaded_at": "2025-05-27T13:20:31.565933"
  },
  "abstract_methods_java11": {
    "text": "8.1. Class Declarations A class declaration specifies a new named reference type. There are two kinds of class declarations: normal class declarations and enum declarations . ClassDeclaration: NormalClassDeclaration EnumDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ Superclass ] [ Superinterfaces ] ClassBody The rules in this section apply to all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to class modifiers, inner classes, and superclasses; these rules are stated in §8.9 . The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final strictfp The rules for annotation modifiers on a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes within a directly enclosing class declaration ( §8.5 ). The modifier static pertains only to member classes ( §8.5.1 ), not to top level or local or anonymous classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private ( §6.6 ). If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. final Classes A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if the name of a final class appears in the extends clause ( §8.1.4 ) of another class declaration; this implies that a final class cannot have any subclasses. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). 8.1.1.3. strictfp Classes The effect of the strictfp modifier is to make all float or double expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict ( §15.4 ). This implies that all methods declared in the class, and all nested types declared in the class, are implicitly strictfp . 8.1.2. Generic Classes and Type Parameters A class is generic if it declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules for annotation modifiers on a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. It is a compile-time error to refer to a type parameter of a generic class C in any of the following: the declaration of a static member of C ( §8.3.1.1 , §8.4.3.2 , §8.5.1 ). the declaration of a static member of any type declaration nested within C . a static initializer of C ( §8.7 ), or a static initializer of any class declaration nested within C . Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly declared static . An inner class may be a non- static member class ( §8.5 ), a local class ( §14.3 ), or an anonymous class ( §15.9.5 ). A member class of an interface is implicitly static ( §9.5 ) so is never considered to be an inner class. It is a compile-time error if an inner class declares a static initializer ( §8.7 ). It is a compile-time error if an inner class declares a member that is explicitly or implicitly static , unless the member is a constant variable ( §4.12.4 ). An inner class may inherit static members that are not constant variables even though it cannot declare them. A nested class that is not an inner class may declare static members freely, in accordance with the usual rules of the Java programming language. Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static final int x = 3; // OK: constant variable static int y = 4; // Compile-time error: an inner class } static class NestedButNotInner{ static int z = 5; // OK: not an inner class } interface NeverInner {} // Interfaces are never inner } A statement or expression occurs in a static context if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement ( §8.8.7.1 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing type declaration of C and the declaration of C does not occur in a static context. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing type declaration of an inner class to be an interface. This only occurs if the class is declared in a default method body ( §9.4 ). Specifically, it occurs if an anonymous or local class is declared in a default method body, or a member class is declared in the body of an anonymous class that is declared in a default method body. A class or interface O is the zeroth lexically enclosing type declaration of itself . A class O is the n'th lexically enclosing type declaration of a class C if it is the immediately enclosing type declaration of the n-1 'th lexically enclosing type declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner class I whose declaration occurs in a static context has no lexically enclosing instances. However, if I is immediately declared within a static method or static initializer then I does have an enclosing block , which is the innermost block statement lexically enclosing the declaration of I . For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing type declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared final or be effectively final ( §4.12.4 ), or a compile-time error occurs where the use is attempted. Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing type declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing type declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing type declaration, the instance variable must be defined with respect to an enclosing instance of that declared type. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass of the current class. Superclass: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass. The ClassType must name an accessible class type ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum or any invocation of Enum ( §8.9 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superclass of the class type C < F 1 ,..., F n > is the type given in the extends clause of the declaration of C if an extends clause is present, or Object otherwise. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superclass of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, is D < U 1 θ ,..., U k θ > , where D < U 1 ,..., U k > is the direct superclass of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . A class is said to be a direct subclass of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived. The subclass relationship is the transitive closure of the direct subclass relationship. A class A is a subclass of class C if either of the following is true: A is the direct subclass of C There exists a class B such that A is a subclass of B , and B is a subclass of C , applying this definition recursively. Class C is said to be a superclass of class A whenever A is a subclass of C . Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a reference type T if any of the following is true: C directly depends on T . C directly depends on an interface I that depends ( §9.1.3 ) on T . C directly depends on a class D that depends on T (using this definition recursively). It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration lists the names of interfaces that are direct superinterfaces of the class being declared. Superinterfaces: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface type ( §6.6 ), or a compile-time error occurs. If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is mentioned as a direct superinterface more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superinterfaces of the class type C < F 1 ,..., F n > are the types given in the implements clause of the declaration of C , if an implements clause is present. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superinterfaces of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, are all types I < U 1 θ ,..., U k θ > , where I < U 1 ,..., U k > is a direct superinterface of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . An interface type I is a superinterface of class type C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to implement all its superinterfaces. A class may not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface ( §9.1.2 ), or a subtype of a parameterization of a generic interface and a raw type naming that same generic interface, or a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-3. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes ( §8.5 ), and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class type C is specified in §6.3 and §6.4 . If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows ( §6.4.1 ) the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "11",
      "section_number": "8.4.3",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.3",
    "section_name": "abstract_methods",
    "downloaded_at": "2025-05-27T13:20:33.163349"
  },
  "abstract_methods_java17": {
    "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required . Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "17",
      "section_number": "8.4.3",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Chapter 8. Classes"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.4.3",
    "section_name": "abstract_methods",
    "downloaded_at": "2025-05-27T13:20:34.871563"
  },
  "abstract_methods_java21": {
    "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required . Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For a record class R , the direct superclass type is Record . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "21",
      "section_number": "8.4.3",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Chapter 8. Classes"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.3",
    "section_name": "abstract_methods",
    "downloaded_at": "2025-05-27T13:20:36.512088"
  },
  "abstract_methods_java24": {
    "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required. Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For a record class R , the direct superclass type is Record . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "24",
      "section_number": "8.4.3",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Chapter 8. Classes"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-8.html#jls-8.4.3",
    "section_name": "abstract_methods",
    "downloaded_at": "2025-05-27T13:20:38.801872"
  },
  "constructors_java8": {
    "text": "8.1. Class Declarations A class declaration specifies a new named reference type. There are two kinds of class declarations: normal class declarations and enum declarations . ClassDeclaration: NormalClassDeclaration EnumDeclaration NormalClassDeclaration: { ClassModifier } class Identifier [ TypeParameters ] [ Superclass ] [ Superinterfaces ] ClassBody The rules in this section apply to all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to class modifiers, inner classes, and superclasses; these rules are stated in §8.9 . The Identifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final strictfp The rules for annotation modifiers on a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes within a directly enclosing class declaration ( §8.5 ). The modifier static pertains only to member classes ( §8.5.1 ), not to top level or local or anonymous classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration. If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. final Classes A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if the name of a final class appears in the extends clause ( §8.1.4 ) of another class declaration; this implies that a final class cannot have any subclasses. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). 8.1.1.3. strictfp Classes The effect of the strictfp modifier is to make all float or double expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict ( §15.4 ). This implies that all methods declared in the class, and all nested types declared in the class, are implicitly strictfp . 8.1.2. Generic Classes and Type Parameters A class is generic if it declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } Identifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules for annotation modifiers on a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. It is a compile-time error to refer to a type parameter of a generic class C in any of the following: the declaration of a static member of C ( §8.3.1.1 , §8.4.3.2 , §8.5.1 ). the declaration of a static member of any type declaration nested within C . a static initializer of C ( §8.7 ), or a static initializer of any class declaration nested within C . Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly declared static . An inner class may be a non- static member class ( §8.5 ), a local class ( §14.3 ), or an anonymous class ( §15.9.5 ). A member class of an interface is implicitly static ( §9.5 ) so is never considered to be an inner class. It is a compile-time error if an inner class declares a static initializer ( §8.7 ). It is a compile-time error if an inner class declares a member that is explicitly or implicitly static , unless the member is a constant variable ( §4.12.4 ). An inner class may inherit static members that are not constant variables even though it cannot declare them. A nested class that is not an inner class may declare static members freely, in accordance with the usual rules of the Java programming language. Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static final int x = 3; // OK: constant variable static int y = 4; // Compile-time error: an inner class } static class NestedButNotInner{ static int z = 5; // OK: not an inner class } interface NeverInner {} // Interfaces are never inner } A statement or expression occurs in a static context if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement ( §8.8.7.1 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing type declaration of C and the declaration of C does not occur in a static context. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing type declaration of an inner class to be an interface. This only occurs if the class is declared in a default method body ( §9.4 ). Specifically, it occurs if an anonymous or local class is declared in a default method body, or a member class is declared in the body of an anonymous class that is declared in a default method body. A class or interface O is the zeroth lexically enclosing type declaration of itself . A class O is the n'th lexically enclosing type declaration of a class C if it is the immediately enclosing type declaration of the n-1 'th lexically enclosing type declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner class I whose declaration occurs in a static context has no lexically enclosing instances. However, if I is immediately declared within a static method or static initializer then I does have an enclosing block , which is the innermost block statement lexically enclosing the declaration of I . For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing type declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared final or be effectively final ( §4.12.4 ), or a compile-time error occurs where the use is attempted. Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing type declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are marked final ). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing type declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing type declaration, the instance variable must be defined with respect to an enclosing instance of that declared type. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass of the current class. Superclass: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass. The ClassType must name an accessible class type ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum or any invocation of Enum ( §8.9 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superclass of the class type C < F 1 ,..., F n > is the type given in the extends clause of the declaration of C if an extends clause is present, or Object otherwise. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superclass of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, is D < U 1 θ ,..., U k θ > , where D < U 1 ,..., U k > is the direct superclass of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . A class is said to be a direct subclass of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived. The subclass relationship is the transitive closure of the direct subclass relationship. A class A is a subclass of class C if either of the following is true: A is the direct subclass of C There exists a class B such that A is a subclass of B , and B is a subclass of C , applying this definition recursively. Class C is said to be a superclass of class A whenever A is a subclass of C . Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a reference type T if any of the following is true: C directly depends on T . C directly depends on an interface I that depends ( §9.1.3 ) on T . C directly depends on a class D that depends on T (using this definition recursively). It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration lists the names of interfaces that are direct superinterfaces of the class being declared. Superinterfaces: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface type ( §6.6 ), or a compile-time error occurs. If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is mentioned as a direct superinterface more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superinterfaces of the class type C < F 1 ,..., F n > are the types given in the implements clause of the declaration of C , if an implements clause is present. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superinterfaces of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, are all types I < U 1 θ ,..., U k θ > , where I < U 1 ,..., U k > is a direct superinterface of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . An interface type I is a superinterface of class type C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to implement all its superinterfaces. A class may not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface ( §9.1.2 ), or a subtype of a parameterization of a generic interface and a raw type naming that same generic interface, or a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-3. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes ( §8.5 ), and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class type C is specified in §6.3 and §6.4 . If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows ( §6.4.1 ) the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "8",
      "section_number": "8.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8",
    "section_name": "constructors",
    "downloaded_at": "2025-05-27T13:20:40.354870"
  },
  "constructors_java11": {
    "text": "8.1. Class Declarations A class declaration specifies a new named reference type. There are two kinds of class declarations: normal class declarations and enum declarations . ClassDeclaration: NormalClassDeclaration EnumDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ Superclass ] [ Superinterfaces ] ClassBody The rules in this section apply to all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to class modifiers, inner classes, and superclasses; these rules are stated in §8.9 . The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final strictfp The rules for annotation modifiers on a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes within a directly enclosing class declaration ( §8.5 ). The modifier static pertains only to member classes ( §8.5.1 ), not to top level or local or anonymous classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private ( §6.6 ). If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. final Classes A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if the name of a final class appears in the extends clause ( §8.1.4 ) of another class declaration; this implies that a final class cannot have any subclasses. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). 8.1.1.3. strictfp Classes The effect of the strictfp modifier is to make all float or double expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict ( §15.4 ). This implies that all methods declared in the class, and all nested types declared in the class, are implicitly strictfp . 8.1.2. Generic Classes and Type Parameters A class is generic if it declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules for annotation modifiers on a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. It is a compile-time error to refer to a type parameter of a generic class C in any of the following: the declaration of a static member of C ( §8.3.1.1 , §8.4.3.2 , §8.5.1 ). the declaration of a static member of any type declaration nested within C . a static initializer of C ( §8.7 ), or a static initializer of any class declaration nested within C . Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly declared static . An inner class may be a non- static member class ( §8.5 ), a local class ( §14.3 ), or an anonymous class ( §15.9.5 ). A member class of an interface is implicitly static ( §9.5 ) so is never considered to be an inner class. It is a compile-time error if an inner class declares a static initializer ( §8.7 ). It is a compile-time error if an inner class declares a member that is explicitly or implicitly static , unless the member is a constant variable ( §4.12.4 ). An inner class may inherit static members that are not constant variables even though it cannot declare them. A nested class that is not an inner class may declare static members freely, in accordance with the usual rules of the Java programming language. Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static final int x = 3; // OK: constant variable static int y = 4; // Compile-time error: an inner class } static class NestedButNotInner{ static int z = 5; // OK: not an inner class } interface NeverInner {} // Interfaces are never inner } A statement or expression occurs in a static context if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement ( §8.8.7.1 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing type declaration of C and the declaration of C does not occur in a static context. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing type declaration of an inner class to be an interface. This only occurs if the class is declared in a default method body ( §9.4 ). Specifically, it occurs if an anonymous or local class is declared in a default method body, or a member class is declared in the body of an anonymous class that is declared in a default method body. A class or interface O is the zeroth lexically enclosing type declaration of itself . A class O is the n'th lexically enclosing type declaration of a class C if it is the immediately enclosing type declaration of the n-1 'th lexically enclosing type declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner class I whose declaration occurs in a static context has no lexically enclosing instances. However, if I is immediately declared within a static method or static initializer then I does have an enclosing block , which is the innermost block statement lexically enclosing the declaration of I . For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing type declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared final or be effectively final ( §4.12.4 ), or a compile-time error occurs where the use is attempted. Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing type declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing type declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing type declaration, the instance variable must be defined with respect to an enclosing instance of that declared type. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass of the current class. Superclass: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass. The ClassType must name an accessible class type ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum or any invocation of Enum ( §8.9 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superclass of the class type C < F 1 ,..., F n > is the type given in the extends clause of the declaration of C if an extends clause is present, or Object otherwise. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superclass of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, is D < U 1 θ ,..., U k θ > , where D < U 1 ,..., U k > is the direct superclass of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . A class is said to be a direct subclass of its direct superclass. The direct superclass is the class from whose implementation the implementation of the current class is derived. The subclass relationship is the transitive closure of the direct subclass relationship. A class A is a subclass of class C if either of the following is true: A is the direct subclass of C There exists a class B such that A is a subclass of B , and B is a subclass of C , applying this definition recursively. Class C is said to be a superclass of class A whenever A is a subclass of C . Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a type T if T is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a reference type T if any of the following is true: C directly depends on T . C directly depends on an interface I that depends ( §9.1.3 ) on T . C directly depends on a class D that depends on T (using this definition recursively). It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration lists the names of interfaces that are direct superinterfaces of the class being declared. Superinterfaces: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface type ( §6.6 ), or a compile-time error occurs. If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is mentioned as a direct superinterface more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. Given a (possibly generic) class declaration C < F 1 ,..., F n > ( n ≥ 0, C ≠ Object ), the direct superinterfaces of the class type C < F 1 ,..., F n > are the types given in the implements clause of the declaration of C , if an implements clause is present. Given a generic class declaration C < F 1 ,..., F n > ( n > 0), the direct superinterfaces of the parameterized class type C < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, are all types I < U 1 θ ,..., U k θ > , where I < U 1 ,..., U k > is a direct superinterface of C < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . An interface type I is a superinterface of class type C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to implement all its superinterfaces. A class may not at the same time be a subtype of two interface types which are different parameterizations of the same generic interface ( §9.1.2 ), or a subtype of a parameterization of a generic interface and a raw type naming that same generic interface, or a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-3. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes ( §8.5 ), and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class type C is specified in §6.3 and §6.4 . If C itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows ( §6.4.1 ) the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "11",
      "section_number": "8.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.8",
    "section_name": "constructors",
    "downloaded_at": "2025-05-27T13:20:41.950146"
  },
  "constructors_java17": {
    "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required . Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "17",
      "section_number": "8.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Chapter 8. Classes"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.8",
    "section_name": "constructors",
    "downloaded_at": "2025-05-27T13:20:43.914279"
  },
  "constructors_java21": {
    "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required . Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For a record class R , the direct superclass type is Record . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "21",
      "section_number": "8.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Chapter 8. Classes"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8",
    "section_name": "constructors",
    "downloaded_at": "2025-05-27T13:20:45.739471"
  },
  "constructors_java24": {
    "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required. Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For a record class R , the direct superclass type is Record . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
    "metadata": {
      "java_version": "24",
      "section_number": "8.8",
      "section_title": "Chapter 8. Classes",
      "chapter_title": "Chapter 8. Classes"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-8.html#jls-8.8",
    "section_name": "constructors",
    "downloaded_at": "2025-05-27T13:20:47.409154"
  },
  "expressions_java8": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations. An expression occurs in either: The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on a package declaration or on a top level type declaration.",
    "metadata": {
      "java_version": "8",
      "section_number": "15.10.2",
      "section_title": "Unknown",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.10.2",
    "section_name": "expressions",
    "downloaded_at": "2025-05-27T13:20:50.157934"
  },
  "expressions_java11": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations. An expression occurs in either: The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on a package declaration or on a top level type declaration.",
    "metadata": {
      "java_version": "11",
      "section_number": "15.10.2",
      "section_title": "Unknown",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.10.2",
    "section_name": "expressions",
    "downloaded_at": "2025-05-27T13:20:52.247310"
  },
  "expressions_java17": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on the declaration of a module, a package, or a top level class or interface.",
    "metadata": {
      "java_version": "17",
      "section_number": "15.10.2",
      "section_title": "Unknown",
      "chapter_title": "Chapter 15. Expressions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.10.2",
    "section_name": "expressions",
    "downloaded_at": "2025-05-27T13:20:54.295572"
  },
  "expressions_java21": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on the declaration of a module, a package, or a top level class or interface.",
    "metadata": {
      "java_version": "21",
      "section_number": "15.10.2",
      "section_title": "Unknown",
      "chapter_title": "Chapter 15. Expressions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.10.2",
    "section_name": "expressions",
    "downloaded_at": "2025-05-27T13:20:57.711713"
  },
  "expressions_java24": {
    "text": "15.1. Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A value ( §4.2 , §4.3 ) Nothing (the expression is said to be void) If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression. An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 ). Such an expression can be used only as an expression statement ( §14.8 ) or as the single expression of a lambda body ( §15.27.2 ), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded. Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, method invocations, and, in switch expressions, arbitrary statements. An expression occurs in either: The declaration of some class or interface that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation. An annotation on the declaration of a module, a package, or a top level class or interface.",
    "metadata": {
      "java_version": "24",
      "section_number": "15.10.2",
      "section_title": "Unknown",
      "chapter_title": "Chapter 15. Expressions"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.10.2",
    "section_name": "expressions",
    "downloaded_at": "2025-05-27T13:20:59.753448"
  },
  "threads_and_locks_java8": {
    "text": "17.1. Synchronization The Java programming language provides multiple mechanisms for communicating between threads. The most basic of these methods is synchronization , which is implemented using monitors . Each object in Java is associated with a monitor, which a thread can lock or unlock . Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor. A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation. The synchronized statement ( §14.19 ) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. A synchronized method ( §8.4.3.6 ) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static , it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary. Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.",
    "metadata": {
      "java_version": "8",
      "section_number": "17",
      "section_title": "Chapter 17. Threads and Locks",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html",
    "section_name": "threads_and_locks",
    "downloaded_at": "2025-05-27T13:21:01.044048"
  },
  "threads_and_locks_java11": {
    "text": "17.1. Synchronization The Java programming language provides multiple mechanisms for communicating between threads. The most basic of these methods is synchronization , which is implemented using monitors . Each object in Java is associated with a monitor, which a thread can lock or unlock . Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor. A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation. The synchronized statement ( §14.19 ) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. A synchronized method ( §8.4.3.6 ) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static , it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary. Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.",
    "metadata": {
      "java_version": "11",
      "section_number": "17",
      "section_title": "Chapter 17. Threads and Locks",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html",
    "section_name": "threads_and_locks",
    "downloaded_at": "2025-05-27T13:21:02.284431"
  },
  "threads_and_locks_java17": {
    "text": "17.1. Synchronization The Java programming language provides multiple mechanisms for communicating between threads. The most basic of these methods is synchronization , which is implemented using monitors . Each object in Java is associated with a monitor, which a thread can lock or unlock . Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor. A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation. The synchronized statement ( §14.19 ) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. A synchronized method ( §8.4.3.6 ) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static , it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary. Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.",
    "metadata": {
      "java_version": "17",
      "section_number": "17",
      "section_title": "Chapter 17. Threads and Locks",
      "chapter_title": "Chapter 17. Threads and Locks"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html",
    "section_name": "threads_and_locks",
    "downloaded_at": "2025-05-27T13:21:03.526148"
  },
  "threads_and_locks_java21": {
    "text": "17.1. Synchronization The Java programming language provides multiple mechanisms for communicating between threads. The most basic of these methods is synchronization , which is implemented using monitors . Each object in Java is associated with a monitor, which a thread can lock or unlock . Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor. A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation. The synchronized statement ( §14.19 ) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. A synchronized method ( §8.4.3.6 ) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static , it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary. Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.",
    "metadata": {
      "java_version": "21",
      "section_number": "17",
      "section_title": "Chapter 17. Threads and Locks",
      "chapter_title": "Chapter 17. Threads and Locks"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-17.html",
    "section_name": "threads_and_locks",
    "downloaded_at": "2025-05-27T13:21:04.763201"
  },
  "threads_and_locks_java24": {
    "text": "17.1. Synchronization The Java programming language provides multiple mechanisms for communicating between threads. The most basic of these methods is synchronization , which is implemented using monitors . Each object in Java is associated with a monitor, which a thread can lock or unlock . Only one thread at a time may hold a lock on a monitor. Any other threads attempting to lock that monitor are blocked until they can obtain a lock on that monitor. A thread t may lock a particular monitor multiple times; each unlock reverses the effect of one lock operation. The synchronized statement ( §14.19 ) computes a reference to an object; it then attempts to perform a lock action on that object's monitor and does not proceed further until the lock action has successfully completed. After the lock action has been performed, the body of the synchronized statement is executed. If execution of the body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. A synchronized method ( §8.4.3.6 ) automatically performs a lock action when it is invoked; its body is not executed until the lock action has successfully completed. If the method is an instance method, it locks the monitor associated with the instance for which it was invoked (that is, the object that will be known as this during execution of the body of the method). If the method is static , it locks the monitor associated with the Class object that represents the class in which the method is defined. If execution of the method's body is ever completed, either normally or abruptly, an unlock action is automatically performed on that same monitor. The Java programming language neither prevents nor requires detection of deadlock conditions. Programs where threads hold (directly or indirectly) locks on multiple objects should use conventional techniques for deadlock avoidance, creating higher-level locking primitives that do not deadlock, if necessary. Other mechanisms, such as reads and writes of volatile variables and the use of classes in the java.util.concurrent package, provide alternative ways of synchronization.",
    "metadata": {
      "java_version": "24",
      "section_number": "17",
      "section_title": "Chapter 17. Threads and Locks",
      "chapter_title": "Chapter 17. Threads and Locks"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-17.html",
    "section_name": "threads_and_locks",
    "downloaded_at": "2025-05-27T13:21:05.984772"
  },
  "type_inference_java8": {
    "text": "18.1. Concepts and Notation This section defines inference variables , constraint formulas , and bounds , as the terms will be used throughout this chapter. It also presents notation. 18.1.1. Inference Variables Inference variables are meta-variables for types - that is, they are special names that allow abstract reasoning about types. To distinguish them from type variables , inference variables are represented with Greek letters, principally α . The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables. The term proper type excludes such \"types\" that mention inference variables. Assertions that involve inference variables are assertions about every proper type that can be produced by replacing each inference variable with a proper type. 18.1.2. Constraint Formulas Constraint formulas are assertions of compatibility or subtyping that may involve inference variables. The formulas may take one of the following forms: ‹ Expression → T ›: An expression is compatible in a loose invocation context with type T ( §5.3 ). ‹ S → T ›: A type S is compatible in a loose invocation context with type T ( §5.3 ). ‹ S <: T ›: A reference type S is a subtype of a reference type T ( §4.10 ). ‹ S <= T ›: A type argument S is contained by a type argument T ( §4.5.1 ). ‹ S = T ›: A type S is the same as a type T ( §4.3.4 ), or a type argument S is the same as type argument T . ‹ LambdaExpression → throws T ›: The checked exceptions thrown by the body of the LambdaExpression are declared by the throws clause of the function type derived from T . ‹ MethodReference → throws T ›: The checked exceptions thrown by the referenced method are declared by the throws clause of the function type derived from T . Examples of constraint formulas: From Collections.singleton(\"hi\") , we have the constraint formula ‹ \"hi\" → α ›. Through reduction, this will become the constraint formula: ‹ String <: α ›. From Arrays.asList(1, 2.0) , we have the constraint formulas ‹ 1 → α › and ‹ 2.0 → α ›. Through reduction, these will become the constraint formulas ‹ int → α › and ‹ double → α ›, and then ‹ Integer <: α › and ‹ Double <: α ›. From the target type of the constructor invocation List<Thread> lt = new ArrayList <> () , we have the constraint formula ‹ ArrayList < α > → List < Thread > ›. Through reduction, this will become the constraint formula ‹ α <= Thread ›, and then ‹ α = Thread ›. 18.1.3. Bounds During the inference process, a set of bounds on inference variables is maintained. A bound has one of the following forms: S = T , where at least one of S or T is an inference variable: S is the same as T . S <: T , where at least one of S or T is an inference variable: S is a subtype of T . false : No valid choice of inference variables exists. G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ): The variables α 1 , ..., α n represent the result of capture conversion ( §5.1.10 ) applied to G < A 1 , ..., A n > (where A 1 , ..., A n may be types or wildcards and may mention inference variables). throws α : The inference variable α appears in a throws clause. A bound is satisfied by an inference variable substitution if, after applying the substitution, the assertion is true. The bound false can never be satisfied. Some bounds relate an inference variable to a proper type. Let T be a proper type. Given a bound of the form α = T or T = α , we say T is an instantiation of α . Similarly, given a bound of the form α <: T , we say T is a proper upper bound of α , and given a bound of the form T <: α , we say T is a proper lower bound of α . Other bounds relate two inference variables, or an inference variable to a type that contains inference variables. Such bounds, of the form S = T or S <: T , are called dependencies . A bound of the form G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ) indicates that α 1 , ..., α n are placeholders for the results of capture conversion. This is necessary because capture conversion can only be performed on a proper type, and the inference variables in A 1 , ..., A n may not yet be resolved. A bound of the form throws α is purely informational: it directs resolution to optimize the instantiation of α so that, if possible, it is not a checked exception type. An important intermediate result of inference is a bound set . It is sometimes convenient to refer to an empty bound set with the symbol true ; this is merely out of convenience, and the two are interchangeable. Examples of bound sets: { α = String } contains a single bound, instantiating α as String . { Integer <: α , Double <: α , α <: Object } describes two proper lower bounds and one proper upper bound for α . { α <: Iterable<?> , β <: Object , α <: List < β > } describes a proper upper bound for each of α and β , along with a dependency between them. { } contains no bounds nor dependencies, and can be referred to as true . { false } expresses the fact that no satisfactory instantiation exists. When inference begins, a bound set is typically generated from a list of type parameter declarations P 1 , ..., P p and associated inference variables α 1 , ..., α p . Such a bound set is constructed as follows. For each l (1 ≤ l ≤ p ): If P l has no TypeBound , the bound α l <: Object appears in the set. Otherwise, for each type T delimited by & in the TypeBound , the bound α l <: T [ P 1 := α 1 , ..., P p := α p ] appears in the set; if this results in no proper upper bounds for α l (only dependencies), then the bound α l <: Object also appears in the set.",
    "metadata": {
      "java_version": "8",
      "section_number": "18",
      "section_title": "Chapter 18. Type Inference",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html",
    "section_name": "type_inference",
    "downloaded_at": "2025-05-27T13:21:07.369800"
  },
  "type_inference_java11": {
    "text": "18.1. Concepts and Notation This section defines inference variables , constraint formulas , and bounds , as the terms will be used throughout this chapter. It also presents notation. 18.1.1. Inference Variables Inference variables are meta-variables for types - that is, they are special names that allow abstract reasoning about types. To distinguish them from type variables , inference variables are represented with Greek letters, principally α . The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables. The term proper type excludes such \"types\" that mention inference variables. Assertions that involve inference variables are assertions about every proper type that can be produced by replacing each inference variable with a proper type. 18.1.2. Constraint Formulas Constraint formulas are assertions of compatibility or subtyping that may involve inference variables. The formulas may take one of the following forms: ‹ Expression → T ›: An expression is compatible in a loose invocation context with type T ( §5.3 ). ‹ S → T ›: A type S is compatible in a loose invocation context with type T ( §5.3 ). ‹ S <: T ›: A reference type S is a subtype of a reference type T ( §4.10 ). ‹ S <= T ›: A type argument S is contained by a type argument T ( §4.5.1 ). ‹ S = T ›: A type S is the same as a type T ( §4.3.4 ), or a type argument S is the same as type argument T . ‹ LambdaExpression → throws T ›: The checked exceptions thrown by the body of the LambdaExpression are declared by the throws clause of the function type derived from T . ‹ MethodReference → throws T ›: The checked exceptions thrown by the referenced method are declared by the throws clause of the function type derived from T . Examples of constraint formulas: From Collections.singleton(\"hi\") , we have the constraint formula ‹ \"hi\" → α ›. Through reduction, this will become the constraint formula: ‹ String <: α ›. From Arrays.asList(1, 2.0) , we have the constraint formulas ‹ 1 → α › and ‹ 2.0 → α ›. Through reduction, these will become the constraint formulas ‹ int → α › and ‹ double → α ›, and then ‹ Integer <: α › and ‹ Double <: α ›. From the target type of the constructor invocation List<Thread> lt = new ArrayList <> () , we have the constraint formula ‹ ArrayList < α > → List < Thread > ›. Through reduction, this will become the constraint formula ‹ α <= Thread ›, and then ‹ α = Thread ›. 18.1.3. Bounds During the inference process, a set of bounds on inference variables is maintained. A bound has one of the following forms: S = T , where at least one of S or T is an inference variable: S is the same as T . S <: T , where at least one of S or T is an inference variable: S is a subtype of T . false : No valid choice of inference variables exists. G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ): The variables α 1 , ..., α n represent the result of capture conversion ( §5.1.10 ) applied to G < A 1 , ..., A n > (where A 1 , ..., A n may be types or wildcards and may mention inference variables). throws α : The inference variable α appears in a throws clause. A bound is satisfied by an inference variable substitution if, after applying the substitution, the assertion is true. The bound false can never be satisfied. Some bounds relate an inference variable to a proper type. Let T be a proper type. Given a bound of the form α = T or T = α , we say T is an instantiation of α . Similarly, given a bound of the form α <: T , we say T is a proper upper bound of α , and given a bound of the form T <: α , we say T is a proper lower bound of α . Other bounds relate two inference variables, or an inference variable to a type that contains inference variables. Such bounds, of the form S = T or S <: T , are called dependencies . A bound of the form G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ) indicates that α 1 , ..., α n are placeholders for the results of capture conversion. This is necessary because capture conversion can only be performed on a proper type, and the inference variables in A 1 , ..., A n may not yet be resolved. A bound of the form throws α is purely informational: it directs resolution to optimize the instantiation of α so that, if possible, it is not a checked exception type. An important intermediate result of inference is a bound set . It is sometimes convenient to refer to an empty bound set with the symbol true ; this is merely out of convenience, and the two are interchangeable. Examples of bound sets: { α = String } contains a single bound, instantiating α as String . { Integer <: α , Double <: α , α <: Object } describes two proper lower bounds and one proper upper bound for α . { α <: Iterable<?> , β <: Object , α <: List < β > } describes a proper upper bound for each of α and β , along with a dependency between them. { } contains no bounds nor dependencies, and can be referred to as true . { false } expresses the fact that no satisfactory instantiation exists. When inference begins, a bound set is typically generated from a list of type parameter declarations P 1 , ..., P p and associated inference variables α 1 , ..., α p . Such a bound set is generated as follows. For each l (1 ≤ l ≤ p ): If P l has no TypeBound , the bound α l <: Object appears in the set. Otherwise, for each type T delimited by & in the TypeBound , the bound α l <: T [ P 1 := α 1 , ..., P p := α p ] appears in the set; if this results in no proper upper bounds for α l (only dependencies), then the bound α l <: Object also appears in the set.",
    "metadata": {
      "java_version": "11",
      "section_number": "18",
      "section_title": "Chapter 18. Type Inference",
      "chapter_title": "Unknown"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-18.html",
    "section_name": "type_inference",
    "downloaded_at": "2025-05-27T13:21:09.793664"
  },
  "type_inference_java17": {
    "text": "18.1. Concepts and Notation This section defines inference variables , constraint formulas , and bounds , as the terms will be used throughout this chapter. It also presents notation. 18.1.1. Inference Variables Inference variables are meta-variables for types - that is, they are special names that allow abstract reasoning about types. To distinguish them from type variables , inference variables are represented with Greek letters, principally α . The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables. The term proper type excludes such \"types\" that mention inference variables. Assertions that involve inference variables are assertions about every proper type that can be produced by replacing each inference variable with a proper type. 18.1.2. Constraint Formulas Constraint formulas are assertions of compatibility or subtyping that may involve inference variables. The formulas may take one of the following forms: ‹ Expression → T ›: An expression is compatible in a loose invocation context with type T ( §5.3 ). ‹ S → T ›: A type S is compatible in a loose invocation context with type T ( §5.3 ). ‹ S <: T ›: A reference type S is a subtype of a reference type T ( §4.10 ). ‹ S <= T ›: A type argument S is contained by a type argument T ( §4.5.1 ). ‹ S = T ›: A type S is the same as a type T ( §4.3.4 ), or a type argument S is the same as type argument T . ‹ LambdaExpression → throws T ›: The checked exceptions thrown by the body of the LambdaExpression are declared by the throws clause of the function type derived from T . ‹ MethodReference → throws T ›: The checked exceptions thrown by the referenced method are declared by the throws clause of the function type derived from T . Examples of constraint formulas: From Collections.singleton(\"hi\") , we have the constraint formula ‹ \"hi\" → α ›. Through reduction, this will become the constraint formula: ‹ String <: α ›. From Arrays.asList(1, 2.0) , we have the constraint formulas ‹ 1 → α › and ‹ 2.0 → α ›. Through reduction, these will become the constraint formulas ‹ int → α › and ‹ double → α ›, and then ‹ Integer <: α › and ‹ Double <: α ›. From the target type of the constructor invocation List<Thread> lt = new ArrayList<>() , we have the constraint formula ‹ ArrayList < α > → List < Thread > ›. Through reduction, this will become the constraint formula ‹ α <= Thread ›, and then ‹ α = Thread ›. 18.1.3. Bounds During the inference process, a set of bounds on inference variables is maintained. A bound has one of the following forms: S = T , where at least one of S or T is an inference variable: S is the same as T . S <: T , where at least one of S or T is an inference variable: S is a subtype of T . false : No valid choice of inference variables exists. G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ): The variables α 1 , ..., α n represent the result of capture conversion ( §5.1.10 ) applied to G < A 1 , ..., A n > (where A 1 , ..., A n may be types or wildcards and may mention inference variables). throws α : The inference variable α appears in a throws clause. A bound is satisfied by an inference variable substitution if, after applying the substitution, the assertion is true. The bound false can never be satisfied. Some bounds relate an inference variable to a proper type. Let T be a proper type. Given a bound of the form α = T or T = α , we say T is an instantiation of α . Similarly, given a bound of the form α <: T , we say T is a proper upper bound of α , and given a bound of the form T <: α , we say T is a proper lower bound of α . Other bounds relate two inference variables, or an inference variable to a type that contains inference variables. Such bounds, of the form S = T or S <: T , are called dependencies . A bound of the form G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ) indicates that α 1 , ..., α n are placeholders for the results of capture conversion. This is necessary because capture conversion can only be performed on a proper type, and the inference variables in A 1 , ..., A n may not yet be resolved. A bound of the form throws α is purely informational: it directs resolution to optimize the instantiation of α so that, if possible, it is not a checked exception type. An important intermediate result of inference is a bound set . It is sometimes convenient to refer to an empty bound set with the symbol true ; this is merely out of convenience, and the two are interchangeable. Examples of bound sets: { α = String } contains a single bound, instantiating α as String . { Integer <: α , Double <: α , α <: Object } describes two proper lower bounds and one proper upper bound for α . { α <: Iterable<?> , β <: Object , α <: List < β > } describes a proper upper bound for each of α and β , along with a dependency between them. { } contains no bounds nor dependencies, and can be referred to as true . { false } expresses the fact that no satisfactory instantiation exists. When inference begins, a bound set is typically generated from a list of type parameter declarations P 1 , ..., P p and associated inference variables α 1 , ..., α p . Such a bound set is generated as follows. For each l (1 ≤ l ≤ p ): If P l has no TypeBound , the bound α l <: Object appears in the set. Otherwise, for each type T delimited by & in the TypeBound , the bound α l <: T [ P 1 := α 1 , ..., P p := α p ] appears in the set; if this results in no proper upper bounds for α l (only dependencies), then the bound α l <: Object also appears in the set.",
    "metadata": {
      "java_version": "17",
      "section_number": "18",
      "section_title": "Chapter 18. Type Inference",
      "chapter_title": "Chapter 18. Type Inference"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-18.html",
    "section_name": "type_inference",
    "downloaded_at": "2025-05-27T13:21:11.517665"
  },
  "type_inference_java21": {
    "text": "18.1. Concepts and Notation This section defines inference variables , constraint formulas , and bounds , as the terms will be used throughout this chapter. It also presents notation. 18.1.1. Inference Variables Inference variables are meta-variables for types - that is, they are special names that allow abstract reasoning about types. To distinguish them from type variables , inference variables are represented with Greek letters, principally α . The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables. The term proper type excludes such \"types\" that mention inference variables. Assertions that involve inference variables are assertions about every proper type that can be produced by replacing each inference variable with a proper type. 18.1.2. Constraint Formulas Constraint formulas are assertions of compatibility or subtyping that may involve inference variables. The formulas may take one of the following forms: ‹ Expression → T ›: An expression is compatible in a loose invocation context with type T ( §5.3 ). ‹ S → T ›: A type S is compatible in a loose invocation context with type T ( §5.3 ). ‹ S <: T ›: A reference type S is a subtype of a reference type T ( §4.10 ). ‹ S <= T ›: A type argument S is contained by a type argument T ( §4.5.1 ). ‹ S = T ›: A type S is the same as a type T ( §4.3.4 ), or a type argument S is the same as type argument T . ‹ LambdaExpression → throws T ›: The checked exceptions thrown by the body of the LambdaExpression are declared by the throws clause of the function type derived from T . ‹ MethodReference → throws T ›: The checked exceptions thrown by the referenced method are declared by the throws clause of the function type derived from T . Examples of constraint formulas: From Collections.singleton(\"hi\") , we have the constraint formula ‹ \"hi\" → α ›. Through reduction, this will become the constraint formula: ‹ String <: α ›. From Arrays.asList(1, 2.0) , we have the constraint formulas ‹ 1 → α › and ‹ 2.0 → α ›. Through reduction, these will become the constraint formulas ‹ int → α › and ‹ double → α ›, and then ‹ Integer <: α › and ‹ Double <: α ›. From the target type of the constructor invocation List<Thread> lt = new ArrayList<>() , we have the constraint formula ‹ ArrayList < α > → List < Thread > ›. Through reduction, this will become the constraint formula ‹ α <= Thread ›, and then ‹ α = Thread ›. 18.1.3. Bounds During the inference process, a set of bounds on inference variables is maintained. A bound has one of the following forms: S = T , where at least one of S or T is an inference variable: S is the same as T . S <: T , where at least one of S or T is an inference variable: S is a subtype of T . false : No valid choice of inference variables exists. G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ): The variables α 1 , ..., α n represent the result of capture conversion ( §5.1.10 ) applied to G < A 1 , ..., A n > (where A 1 , ..., A n may be types or wildcards and may mention inference variables). throws α : The inference variable α appears in a throws clause. A bound is satisfied by an inference variable substitution if, after applying the substitution, the assertion is true. The bound false can never be satisfied. Some bounds relate an inference variable to a proper type. Let T be a proper type. Given a bound of the form α = T or T = α , we say T is an instantiation of α . Similarly, given a bound of the form α <: T , we say T is a proper upper bound of α , and given a bound of the form T <: α , we say T is a proper lower bound of α . Other bounds relate two inference variables, or an inference variable to a type that contains inference variables. Such bounds, of the form S = T or S <: T , are called dependencies . A bound of the form G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ) indicates that α 1 , ..., α n are placeholders for the results of capture conversion. This is necessary because capture conversion can only be performed on a proper type, and the inference variables in A 1 , ..., A n may not yet be resolved. A bound of the form throws α is purely informational: it directs resolution to optimize the instantiation of α so that, if possible, it is not a checked exception type. An important intermediate result of inference is a bound set . It is sometimes convenient to refer to an empty bound set with the symbol true ; this is merely out of convenience, and the two are interchangeable. Examples of bound sets: { α = String } contains a single bound, instantiating α as String . { Integer <: α , Double <: α , α <: Object } describes two proper lower bounds and one proper upper bound for α . { α <: Iterable<?> , β <: Object , α <: List < β > } describes a proper upper bound for each of α and β , along with a dependency between them. { } contains no bounds nor dependencies, and can be referred to as true . { false } expresses the fact that no satisfactory instantiation exists. When inference begins, a bound set is typically generated from a list of type parameter declarations P 1 , ..., P p and associated inference variables α 1 , ..., α p . Such a bound set is generated as follows. For each l (1 ≤ l ≤ p ): If P l has no TypeBound , the bound α l <: Object appears in the set. Otherwise, for each type T delimited by & in the TypeBound , the bound α l <: T [ P 1 := α 1 , ..., P p := α p ] appears in the set; if this results in no proper upper bounds for α l (only dependencies), then the bound α l <: Object also appears in the set.",
    "metadata": {
      "java_version": "21",
      "section_number": "18",
      "section_title": "Chapter 18. Type Inference",
      "chapter_title": "Chapter 18. Type Inference"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-18.html",
    "section_name": "type_inference",
    "downloaded_at": "2025-05-27T13:21:12.960499"
  },
  "type_inference_java24": {
    "text": "18.1. Concepts and Notation This section defines inference variables , constraint formulas , and bounds , as the terms will be used throughout this chapter. It also presents notation. 18.1.1. Inference Variables Inference variables are meta-variables for types - that is, they are special names that allow abstract reasoning about types. To distinguish them from type variables , inference variables are represented with Greek letters, principally α . The term \"type\" is used loosely in this chapter to include type-like syntax that contains inference variables. The term proper type excludes such \"types\" that mention inference variables. Assertions that involve inference variables are assertions about every proper type that can be produced by replacing each inference variable with a proper type. 18.1.2. Constraint Formulas Constraint formulas are assertions of compatibility or subtyping that may involve inference variables. The formulas may take one of the following forms: ‹ Expression → T ›: An expression is compatible in a loose invocation context with type T ( §5.3 ). ‹ S → T ›: A type S is compatible in a loose invocation context with type T ( §5.3 ). ‹ S <: T ›: A reference type S is a subtype of a reference type T ( §4.10 ). ‹ S <= T ›: A type argument S is contained by a type argument T ( §4.5.1 ). ‹ S = T ›: A type S is the same as a type T ( §4.3.4 ), or a type argument S is the same as type argument T . ‹ LambdaExpression → throws T ›: The checked exceptions thrown by the body of the LambdaExpression are declared by the throws clause of the function type derived from T . ‹ MethodReference → throws T ›: The checked exceptions thrown by the referenced method are declared by the throws clause of the function type derived from T . Examples of constraint formulas: From Collections.singleton(\"hi\") , we have the constraint formula ‹ \"hi\" → α ›. Through reduction, this will become the constraint formula: ‹ String <: α ›. From Arrays.asList(1, 2.0) , we have the constraint formulas ‹ 1 → α › and ‹ 2.0 → α ›. Through reduction, these will become the constraint formulas ‹ int → α › and ‹ double → α ›, and then ‹ Integer <: α › and ‹ Double <: α ›. From the target type of the constructor invocation List<Thread> lt = new ArrayList<>() , we have the constraint formula ‹ ArrayList < α > → List < Thread > ›. Through reduction, this will become the constraint formula ‹ α <= Thread ›, and then ‹ α = Thread ›. 18.1.3. Bounds During the inference process, a set of bounds on inference variables is maintained. A bound has one of the following forms: S = T , where at least one of S or T is an inference variable: S is the same as T . S <: T , where at least one of S or T is an inference variable: S is a subtype of T . false : No valid choice of inference variables exists. G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ): The variables α 1 , ..., α n represent the result of capture conversion ( §5.1.10 ) applied to G < A 1 , ..., A n > (where A 1 , ..., A n may be types or wildcards and may mention inference variables). throws α : The inference variable α appears in a throws clause. A bound is satisfied by an inference variable substitution if, after applying the substitution, the assertion is true. The bound false can never be satisfied. Some bounds relate an inference variable to a proper type. Let T be a proper type. Given a bound of the form α = T or T = α , we say T is an instantiation of α . Similarly, given a bound of the form α <: T , we say T is a proper upper bound of α , and given a bound of the form T <: α , we say T is a proper lower bound of α . Other bounds relate two inference variables, or an inference variable to a type that contains inference variables. Such bounds, of the form S = T or S <: T , are called dependencies . A bound of the form G < α 1 , ..., α n > = capture( G < A 1 , ..., A n > ) indicates that α 1 , ..., α n are placeholders for the results of capture conversion. This is necessary because capture conversion can only be performed on a proper type, and the inference variables in A 1 , ..., A n may not yet be resolved. A bound of the form throws α is purely informational: it directs resolution to optimize the instantiation of α so that, if possible, it is not a checked exception type. An important intermediate result of inference is a bound set . It is sometimes convenient to refer to an empty bound set with the symbol true ; this is merely out of convenience, and the two are interchangeable. Examples of bound sets: { α = String } contains a single bound, instantiating α as String . { Integer <: α , Double <: α , α <: Object } describes two proper lower bounds and one proper upper bound for α . { α <: Iterable<?> , β <: Object , α <: List < β > } describes a proper upper bound for each of α and β , along with a dependency between them. { } contains no bounds nor dependencies, and can be referred to as true . { false } expresses the fact that no satisfactory instantiation exists. When inference begins, a bound set is typically generated from a list of type parameter declarations P 1 , ..., P p and associated inference variables α 1 , ..., α p . Such a bound set is generated as follows. For each l (1 ≤ l ≤ p ): If P l has no TypeBound , the bound α l <: Object appears in the set. Otherwise, for each type T delimited by & in the TypeBound , the bound α l <: T [ P 1 := α 1 , ..., P p := α p ] appears in the set; if this results in no proper upper bounds for α l (only dependencies), then the bound α l <: Object also appears in the set.",
    "metadata": {
      "java_version": "24",
      "section_number": "18",
      "section_title": "Chapter 18. Type Inference",
      "chapter_title": "Chapter 18. Type Inference"
    },
    "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-18.html",
    "section_name": "type_inference",
    "downloaded_at": "2025-05-27T13:21:14.373254"
  }
}