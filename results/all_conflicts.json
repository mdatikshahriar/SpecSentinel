[
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_8_11",
    "rule1_version": "8",
    "rule2_version": "11",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Unknown",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The Java 8 rule mandates that when an expression denotes a variable, its value must be used for further evaluation, establishing a strict requirement. The Java 11 rule softens this by stating that if an expression denotes a variable or a value, it may be referred to simply as the value of the expression, introducing optionality. This reflects a change in wording and modality between versions rather than a direct contradiction or ambiguity.",
    "affected_scenarios": [
      "Expression evaluation involving variables where the interpretation of 'denotes' and 'value' is relevant during compilation and runtime"
    ],
    "resolution_needed": "Clarification on whether the Java 11 wording implies a relaxation of the Java 8 requirement or is merely a stylistic change without semantic impact",
    "detected_at": "2025-05-29T06:10:21.343462",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_15_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The Java 8 rule mandates that when an expression denotes a variable, its value must be used for further evaluation, implying a strict requirement. The Java 17 rule softens this by stating that if an expression denotes a variable or a value, it may be referred to simply as the value of the expression, introducing optionality and less strictness. This reflects a change in how expression evaluation results are described and possibly handled between versions.",
    "affected_scenarios": [
      "Expression evaluation contexts where the distinction between variable denotation and value denotation affects interpretation or implementation",
      "Compiler or runtime components relying on strict mandatory interpretation of expression denotation"
    ],
    "resolution_needed": "Clarification on whether the Java 17 wording implies a relaxation of the mandatory use of variable values during expression evaluation or is merely a linguistic simplification without semantic impact.",
    "detected_at": "2025-05-29T06:10:52.497666",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_16_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The Java 8 rule broadly states that an expression can denote a variable, a value, or nothing (void), without restricting the 'nothing' case to method invocations. The Java 17 rule narrows the 'denotes nothing' case exclusively to method invocations of void methods. This represents a change in the specification between versions, potentially affecting interpretation of expressions that denote nothing outside void method calls.",
    "affected_scenarios": [
      "Expressions that denote nothing but are not method invocations of void methods (e.g., standalone void expressions or other void contexts)",
      "Code relying on the broader interpretation of 'denotes nothing' in Java 8"
    ],
    "resolution_needed": "Clarify whether expressions other than void method invocations can denote nothing in Java 17 and later, and explicitly state the scope of 'denotes nothing' to avoid ambiguity across versions.",
    "detected_at": "2025-05-29T06:10:58.713819",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_21_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The Java 8 rule mandates that when an expression denotes a variable and a value is required, the value of that variable must be used (a must modality). The Java 21 rule relaxes this by stating that if the expression denotes a variable or a value, we may simply speak of the value of the expression (a may modality). This indicates a shift from a strict requirement to a permissive statement, reflecting a change in specification between versions rather than a direct contradiction or ambiguity.",
    "affected_scenarios": [
      "Expression evaluation involving variables where the value is required for further computation"
    ],
    "resolution_needed": "Clarification on whether the permissive 'may' in Java 21 replaces or supplements the mandatory 'must' in Java 8, and how this affects compiler/runtime behavior.",
    "detected_at": "2025-05-29T06:11:23.917267",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_22_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) broadly states that expressions can denote a variable, a value, or nothing (void), without restricting which expressions denote nothing. Rule 2 (Java 21) narrows the condition for an expression denoting nothing exclusively to method invocations of void methods. This represents a change in the specification between versions, potentially affecting interpretation of which expressions denote nothing.",
    "affected_scenarios": [
      "Expressions other than void method invocations that might have been considered to denote nothing under Java 8 but are not covered by the Java 21 rule",
      "Void method invocations where the denotation of 'nothing' is explicitly defined in Java 21"
    ],
    "resolution_needed": "Clarify whether the broader 'denotes nothing' category from Java 8 is superseded by the more restrictive Java 21 definition, and specify how expressions other than void method invocations are treated in terms of denotation.",
    "detected_at": "2025-05-29T06:11:31.970141",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_26_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The two rules are identical in wording and intent but originate from different Java versions (Java 8 vs Java 24). This indicates a version change rather than a contradiction or ambiguity. The rule has been preserved across versions without modification, so no functional conflict exists, but the difference in version references may cause confusion about which version applies in a given context.",
    "affected_scenarios": [
      "Developers or tools referencing different Java versions may be uncertain about which rule to apply."
    ],
    "resolution_needed": "Clarify that the rule remains consistent across versions and specify which version's rule applies in a given context to avoid confusion.",
    "detected_at": "2025-05-29T06:11:51.799529",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [
      "('one', 'CARDINAL')",
      "('4.2', 'CARDINAL')",
      "('4.12', 'CARDINAL')",
      "('4.3', 'CARDINAL')",
      "('three', 'CARDINAL')"
    ],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_27_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The first rule (Java 8) mandates that when an expression denotes a variable and a value is required, the value of that variable must be used, establishing a strict evaluation behavior. The second rule (Java 24) relaxes this by stating that if the expression denotes a variable or a value, we may simply speak of the value of the expression, introducing a permissive or descriptive tone rather than a strict requirement. This reflects a change in wording and modality ('must' vs 'may') between Java versions, indicating an evolution in specification rather than a direct contradiction or ambiguity.",
    "affected_scenarios": [
      "Expression evaluation where the expression denotes a variable and a value is required for further evaluation"
    ],
    "resolution_needed": "Clarification on whether the permissive language in Java 24 replaces or supplements the mandatory behavior in Java 8, and how this affects runtime evaluation requirements.",
    "detected_at": "2025-05-29T06:11:57.227633",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_527_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "8.4.8",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 8. Classes",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 8. Classes",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 describes general expression evaluation at runtime without restrictions on static initializers or static members in inner classes. Rule 2 states that prior to Java SE 16, inner classes could not declare static initializers or non-constant static members, which is a compile-time restriction. This indicates a change in the language specification over versions regarding static members in inner classes, potentially affecting how expressions involving such members are evaluated.",
    "affected_scenarios": [
      "Compilation and runtime evaluation of inner classes with static initializers or static members before and after Java SE 16",
      "Use of static members in inner classes in Java versions prior to 16 versus Java 16 and later"
    ],
    "resolution_needed": "Clarify the version-specific applicability of static member restrictions in inner classes and how expression evaluation semantics adapt accordingly across Java versions.",
    "detected_at": "2025-05-29T06:35:49.382946",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x ...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-8.html#jls-8.4.8",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_613_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The Java 8 rule mandates that when an expression denotes a variable, its value must be used if a value is required, establishing a strict evaluation behavior. The Java 17 rule softens this by stating that if an expression denotes a variable or a value, one may simply speak of the value of the expression, introducing a more permissive or informal interpretation. This reflects an evolution in specification wording rather than a direct contradiction or ambiguity, but it changes the normative strength of the rule.",
    "affected_scenarios": [
      "Expression evaluation involving variables where the value is required for further computation or method resolution"
    ],
    "resolution_needed": "Clarify whether the Java 17 wording replaces or supplements the Java 8 mandatory evaluation behavior, and specify the normative effect on expression evaluation semantics.",
    "detected_at": "2025-05-29T06:39:28.316274",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_614_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) states that an expression may denote 'nothing' (void) without specifying that this is exclusively tied to void method invocations. Rule 2 (Java 17) refines this by stating that an expression denotes nothing if and only if it is a method invocation of a void method. This represents a tightening of the condition for an expression denoting nothing, potentially changing interpretation of expressions that denote nothing in Java 8 but would not under Java 17.",
    "affected_scenarios": [
      "Evaluation of expressions that denote nothing but are not void method invocations",
      "Void method invocation expressions"
    ],
    "resolution_needed": "Clarification on whether expressions other than void method invocations can denote nothing, and explicit statement of the evolution of this rule across Java versions.",
    "detected_at": "2025-05-29T06:39:32.075121",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_619_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The Java 8 rule mandates that when an expression denotes a variable, its value must be used for further evaluation, establishing a strict requirement. The Java 21 rule relaxes this by stating that if an expression denotes a variable or a value, we may simply refer to the value of the expression, introducing optionality ('may') rather than obligation ('must'). This reflects a change in wording and modality between versions rather than a direct contradiction or ambiguity.",
    "affected_scenarios": [
      "Expression evaluation involving variables where the value is required for further computation"
    ],
    "resolution_needed": "Clarification on whether the Java 21 wording implies a semantic change in evaluation requirements or is merely a stylistic/modality adjustment.",
    "detected_at": "2025-05-29T06:39:46.342991",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_620_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The Java 8 rule broadly states that an expression can denote a variable, a value, or nothing (void), without restricting which expressions denote nothing. The Java 21 rule narrows the condition for an expression denoting nothing exclusively to method invocations of void methods. This represents a change in the specification between versions, potentially affecting interpretation of which expressions denote nothing.",
    "affected_scenarios": [
      "Expressions other than void method invocations that might have been considered to denote nothing under Java 8 but are not covered by the Java 21 rule",
      "Void method invocation expressions in both versions"
    ],
    "resolution_needed": "Clarification on how expressions denoting nothing are defined across versions and whether the Java 21 rule supersedes or restricts the broader Java 8 definition.",
    "detected_at": "2025-05-29T06:39:50.126015",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_624_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The two rules are identical in wording and intent but come from different Java versions (Java 8 vs Java 24). This indicates a version change rather than a conflict in the rule itself. There is no contradiction, ambiguity, or overlap in the content; the rule has been preserved across versions.",
    "affected_scenarios": [
      "Expression evaluation behavior consistency across Java 8 and Java 24 runtimes"
    ],
    "resolution_needed": "Clarify that the rule is stable across versions and confirm no semantic changes occurred between Java 8 and Java 24 for this rule.",
    "detected_at": "2025-05-29T06:40:12.284372",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [
      "('one', 'CARDINAL')",
      "('4.2', 'CARDINAL')",
      "('4.12', 'CARDINAL')",
      "('4.3', 'CARDINAL')",
      "('three', 'CARDINAL')"
    ],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_625_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The first rule from Java 8 mandates that when an expression denotes a variable and a value is required, the value of that variable must be used, implying a strict requirement. The second rule from Java 24 relaxes this by stating that if an expression denotes a variable or a value, we may simply speak of the value of the expression, introducing optionality ('may') rather than obligation ('must'). This reflects a change in the specification's modality and potentially its interpretation over versions.",
    "affected_scenarios": [
      "Expression evaluation where the expression denotes a variable and a value is needed for further evaluation"
    ],
    "resolution_needed": "Clarification on how the modality shift from 'must' to 'may' affects runtime behavior and compiler enforcement, and whether the newer rule supersedes or supplements the older one.",
    "detected_at": "2025-05-29T06:40:15.915503",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_1271_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "8.4.3",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 8. Classes",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 8. Classes",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 describes expression evaluation semantics that are stable across Java versions and concern runtime behavior, while Rule 2 describes a compile-time restriction on static members in inner classes that changed between Java 8 and Java 21. Specifically, prior to Java SE 16, inner classes could not declare static initializers or non-constant static members, but this restriction was relaxed in later versions. This represents a version-based change in language rules rather than a direct contradiction or ambiguity.",
    "affected_scenarios": [
      "Declaring static initializers or static non-constant members inside inner classes in Java versions before and after SE 16",
      "Evaluating expressions involving variables declared in inner classes with static members"
    ],
    "resolution_needed": "Clarify the version-specific applicability of static member restrictions in inner classes and explicitly document the evolution of these rules to avoid confusion when migrating code between Java versions.",
    "detected_at": "2025-05-29T07:09:03.485375",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x ...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.3",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_1980_11",
    "rule1_version": "8",
    "rule2_version": "11",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Unknown",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The Java 8 rule mandates that when an expression denotes a variable, its value must be used if a value is required, establishing a strict evaluation behavior at runtime. The Java 11 rule relaxes this by stating that if an expression denotes a variable or a value, we may simply refer to the value of the expression, introducing optionality ('may') and a more general phrasing without explicit runtime scope. This reflects a change in specification wording and modality between versions rather than a direct contradiction or ambiguity.",
    "affected_scenarios": [
      "Expression evaluation involving variables where the value is required for further computation"
    ],
    "resolution_needed": "Clarify the intended strictness and modality of expression evaluation between Java versions and whether the 'may' in Java 11 implies any change in runtime behavior or is purely terminological.",
    "detected_at": "2025-05-29T07:39:32.396083",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_1987_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The Java 8 rule mandates that when an expression denotes a variable, its value must be used if a value is required, establishing a strict evaluation protocol at runtime. The Java 17 rule softens this by stating that if an expression denotes a variable or a value, it may be referred to simply as the value of the expression, introducing optionality and a more relaxed interpretation without specifying runtime enforcement. This reflects an evolution in specification rather than a direct contradiction or ambiguity.",
    "affected_scenarios": [
      "Expression evaluation contexts where the distinction between variable denotation and value usage is critical, especially in runtime evaluation semantics."
    ],
    "resolution_needed": "Clarify whether the Java 17 'may' phrasing replaces or supplements the Java 8 'must' requirement, and specify the intended runtime implications to avoid confusion in implementation and interpretation.",
    "detected_at": "2025-05-29T07:39:55.859258",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_1993_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The two rules describe the denotation of expressions in Java but differ in modality and phrasing across versions. Java 8 mandates that an expression evaluation must denote a variable, value, or nothing, with a strict interpretation of when a variable's value is used. Java 21 softens this by stating that if an expression denotes a variable or value, it may be referred to simply as the value of the expression, implying a more flexible or simplified conceptual model. This reflects an evolution in specification rather than a direct contradiction or ambiguity.",
    "affected_scenarios": [
      "Interpretation of expression evaluation results in Java 8 vs Java 21",
      "Compiler or tool implementations referencing expression denotation semantics"
    ],
    "resolution_needed": "Clarify that the Java 21 rule supersedes or refines the Java 8 rule to avoid confusion about mandatory vs optional phrasing and to confirm intended runtime behavior remains consistent.",
    "detected_at": "2025-05-29T07:40:15.899687",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_0_8",
    "rule2_id": "rule_1994_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "SCOPE_CONFLICT",
    "severity": "MEDIUM",
    "description": "RULE 1 (Java 8) describes expression evaluation at runtime, stating expressions can denote a variable, a value, or nothing (void). RULE 2 (Java 21) restricts 'denotes nothing' specifically to void method invocations at compile-time. The difference in scope (runtime vs. compile-time) and specificity (general expressions vs. void method calls) can cause confusion about when and how 'denotes nothing' applies, especially for expressions other than void method invocations.",
    "affected_scenarios": [
      "Expressions evaluated at runtime that denote nothing but are not void method invocations",
      "Compile-time analysis of expressions that might denote nothing beyond void method calls"
    ],
    "resolution_needed": "Clarify the relationship and precedence between runtime and compile-time rules for expressions denoting nothing, and whether 'denotes nothing' applies exclusively to void method invocations or more broadly at runtime.",
    "detected_at": "2025-05-29T07:40:20.111975",
    "rule1_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_20_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The Java 8 rule uses a permissive modality ('may') when referring to the value of an expression denoting a variable or value, implying optional or informal usage. The Java 21 rule formalizes this by specifying a mandatory modality ('must') at runtime, clarifying that if an expression denotes a variable and a value is required, the value must be used. This represents an evolution in specification strictness rather than a direct contradiction.",
    "affected_scenarios": [
      "Interpretation of expression evaluation semantics in Java 8 versus Java 21",
      "Compiler/runtime behavior regarding when the value of a variable-denoting expression must be used"
    ],
    "resolution_needed": "Clarify that the Java 21 rule supersedes the Java 8 permissive statement by establishing a mandatory runtime requirement, and specify the contexts (compile-time vs runtime) where each applies to avoid confusion.",
    "detected_at": "2025-05-29T07:45:49.583829",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_22_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The Java 8 rule states that if an expression denotes a variable or a value, it may be spoken of simply as the value of the expression, implying expressions generally denote values. The Java 21 rule explicitly states that expressions that are method invocations of void methods denote nothing. This represents a change in the definition of what expressions denote between versions, clarifying that some expressions (void method invocations) do not denote any value. While not a direct contradiction, this is a semantic change that affects interpretation of expressions in method resolution.",
    "affected_scenarios": [
      "Expressions that are method invocations of void methods",
      "Contexts where the value of an expression is assumed or required"
    ],
    "resolution_needed": "Clarify in documentation and tooling that expressions invoking void methods denote nothing, superseding the earlier more general notion that expressions denote values.",
    "detected_at": "2025-05-29T07:45:54.879123",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_26_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The Java 8 rule uses a permissive modality ('may') when referring to speaking simply of the value of an expression that denotes a variable or value, implying flexibility in interpretation. The Java 24 rule, however, mandates ('must') that when an expression denotes a variable and a value is required, the value of that variable is used for further evaluation, indicating a stricter, more explicit requirement. This represents a change in the specification's strictness and clarity between versions rather than a direct contradiction.",
    "affected_scenarios": [
      "Expression evaluation contexts where the value of a variable-denoting expression is used for further computation"
    ],
    "resolution_needed": "Clarify the intended modality and whether the permissive language in Java 8 was superseded by the mandatory requirement in Java 24, to avoid confusion about whether using the value is optional or required.",
    "detected_at": "2025-05-29T07:46:06.892092",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_531_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "8.4.8",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 8. Classes",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 8. Classes",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The first rule from Java 8 uses permissive language ('may speak simply of the value of the expression') without explicitly forbidding unqualified instance method invocations on lexically enclosing classes. The second rule from a later Java version (Java 24) explicitly prohibits unqualified invocations of instance methods of any lexically enclosing class or interface declaration at compile-time. This indicates a change in the language specification between versions, potentially affecting code compatibility and method resolution behavior.",
    "affected_scenarios": [
      "Unqualified invocation of instance methods of lexically enclosing classes or interfaces",
      "Method resolution contexts where expressions denote variables or values that might be instance methods"
    ],
    "resolution_needed": "Clarification on how method resolution rules evolved between Java 8 and later versions, specifically regarding unqualified instance method invocations on lexically enclosing classes, and guidance on migration or compatibility.",
    "detected_at": "2025-05-29T08:04:04.725249",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-8.html#jls-8.4.8",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_614_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The Java 8 rule uses a permissive modality ('may') to state that if an expression denotes a variable or value, it may be spoken of simply as the value of the expression, implying expressions generally denote something. The Java 17 rule introduces a precise condition ('if and only if') that expressions denote nothing only if they are method invocations of void methods. This represents a tightening and formalization of the concept of 'denotes' between versions, changing the interpretation of when expressions denote values or nothing. While not a direct contradiction, this change affects understanding of expression denotation between versions.",
    "affected_scenarios": [
      "Interpreting whether a void method invocation expression denotes a value or nothing",
      "General reasoning about expression denotation in method resolution contexts"
    ],
    "resolution_needed": "Clarify the evolution of the term 'denotes' across Java versions and explicitly state how expressions involving void methods are treated in earlier versions versus later versions to avoid confusion.",
    "detected_at": "2025-05-29T08:07:22.340841",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_626_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The Java 8 rule allows an expression that denotes a variable or value to be considered as having a value, implying that expressions generally denote something. The Java 24 rule explicitly states that expressions invoking void methods denote nothing, introducing a stricter and more precise condition. This represents a change in the specification between versions, potentially affecting interpretation of expressions involving void method invocations.",
    "affected_scenarios": [
      "Expressions that are method invocations of void methods",
      "Contexts where the value of an expression is assumed or required"
    ],
    "resolution_needed": "Clarification on how expressions involving void method invocations should be treated in contexts expecting a value, and explicit guidance on the transition from Java 8 to later versions regarding expression denotation.",
    "detected_at": "2025-05-29T08:08:03.848330",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_1161_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "8.4.3",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 8. Classes",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 8. Classes",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The first rule from Java 8 uses permissive language ('may') regarding expressions denoting variables or values in method resolution contexts, implying some flexibility. The second rule from Java 17 explicitly prohibits unqualified invocations of instance methods of lexically enclosing classes or interfaces at compile-time, representing a stricter constraint. This indicates a change in the language specification between versions, potentially affecting how method resolution is handled in nested contexts.",
    "affected_scenarios": [
      "Unqualified invocation of instance methods of lexically enclosing classes or interfaces in nested classes or interfaces",
      "Method resolution involving expressions denoting variables or values that refer to instance methods in enclosing scopes"
    ],
    "resolution_needed": "Clarification on how method resolution rules evolved from Java 8 to Java 17, specifically regarding unqualified instance method invocations in nested contexts, and explicit guidance on handling such invocations in intermediate Java versions.",
    "detected_at": "2025-05-29T08:25:22.218476",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.4.3",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_1275_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "8.4.3",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 8. Classes",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 8. Classes",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The first rule from Java 8 allows referring to the value of an expression denoting a variable or value in method resolution contexts, implying some flexibility ('may'). The second rule from Java 21 explicitly prohibits unqualified invocations of instance methods of any lexically enclosing class or interface, a stricter constraint that limits such invocations at compile-time. This represents a change in the language specification between versions, tightening the rules around method invocation resolution and disallowing certain usages previously permitted or ambiguously allowed.",
    "affected_scenarios": [
      "Unqualified invocation of instance methods of lexically enclosing classes or interfaces in Java 8 versus Java 21",
      "Method resolution contexts involving expressions denoting variables or values that might have been allowed in Java 8 but are disallowed in Java 21"
    ],
    "resolution_needed": "Clarify the evolution of method invocation rules from Java 8 to Java 21, explicitly stating the deprecation or prohibition of unqualified instance method invocations on lexically enclosing classes or interfaces, and how this affects expression value referencing in method resolution.",
    "detected_at": "2025-05-29T08:29:32.784317",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.3",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_1389_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "8.4.3",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 8. Classes",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 8. Classes",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 from Java 8 allows referring to the value of an expression denoting a variable or value in method resolution contexts, implying some flexibility ('may'). Rule 2 from a later Java version (Java 24) explicitly prohibits unqualified invocations of instance methods of any lexically enclosing class or interface, which restricts method resolution in such contexts. This represents a change in the language specification between versions, potentially affecting how method invocations are resolved and allowed.",
    "affected_scenarios": [
      "Unqualified invocation of instance methods from lexically enclosing classes or interfaces in codebases migrating from Java 8 to Java 24",
      "Method resolution involving expressions denoting variables or values where previously allowed but now disallowed"
    ],
    "resolution_needed": "Clarification on how method resolution rules evolved between Java 8 and Java 24, specifically regarding unqualified instance method invocations and the treatment of expressions denoting variables or values.",
    "detected_at": "2025-05-29T08:33:16.938746",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-8.html#jls-8.4.3",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_1905_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "8.8",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 8. Classes",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 8. Classes",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The first rule from Java 8 allows referring to the value of an expression denoting a variable or value in method resolution contexts, implying some flexibility ('may'). The second rule from a later Java version (Java 24) explicitly prohibits unqualified invocations of instance methods of any lexically enclosing class or interface declaration at compile-time. This represents a change in the language specification regarding method invocation rules, reflecting a stricter constraint in the newer version. While not a direct contradiction, it is a clear evolution that affects how method resolution is handled, potentially invalidating some usages allowed or implied in Java 8.",
    "affected_scenarios": [
      "Unqualified invocation of instance methods of lexically enclosing classes or interfaces in codebases migrating from Java 8 to Java 24",
      "Method resolution involving expressions denoting variables or values where earlier versions allowed more permissive interpretation"
    ],
    "resolution_needed": "Clarification on backward compatibility and explicit guidance on handling unqualified instance method invocations in lexically enclosing contexts across Java versions",
    "detected_at": "2025-05-29T08:48:58.746063",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-8.html#jls-8.8",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_1979_11",
    "rule1_version": "8",
    "rule2_version": "11",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Unknown",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The Java 8 rule uses a permissive modality ('may') when referring to expressions denoting variables or values, implying flexibility in interpretation. The Java 11 rule, however, uses a mandatory modality ('must') for expression evaluation results, explicitly defining that expressions must denote a variable, a value, or nothing, and specifying the use of the variable's value when required. This represents a tightening of the specification between versions rather than a direct contradiction.",
    "affected_scenarios": [
      "Interpretation of expression denotation during compile-time versus runtime evaluation",
      "Compiler or tool implementations that rely on the permissive 'may' modality from Java 8 versus the stricter 'must' modality in Java 11"
    ],
    "resolution_needed": "Clarification on how the permissive language in Java 8 relates to the stricter Java 11 rule, especially regarding compile-time versus runtime contexts and whether the Java 11 rule supersedes or refines the earlier guidance.",
    "detected_at": "2025-05-29T08:51:10.387406",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_1988_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The Java 8 rule states that if an expression denotes a variable or a value, we may speak simply of the value of the expression, implying expressions generally denote values. The Java 17 rule explicitly states that an expression denotes nothing if and only if it is a void method invocation. This represents a refinement and change in the definition of when an expression denotes a value or nothing, clarifying that void method invocations do not denote values. The difference arises from the evolution of the specification between Java 8 and Java 17, potentially causing confusion when interpreting expressions across versions.",
    "affected_scenarios": [
      "Evaluating the denotation of expressions involving void method invocations",
      "Interpreting whether an expression denotes a value or nothing in method resolution"
    ],
    "resolution_needed": "Clarify the evolution of the definition of 'denotes' across Java versions and explicitly state how void method invocations are treated in earlier versions to avoid confusion.",
    "detected_at": "2025-05-29T08:51:45.063861",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_1994_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The Java 8 rule (Section 15.12) states that if an expression denotes a variable or a value, it may be spoken of simply as the value of the expression, implying expressions generally denote values. The Java 21 rule (Section 15.10.2) explicitly states that an expression denotes nothing if and only if it is a method invocation of a void method. This represents a refinement and clarification of the denotation concept between versions, changing the understanding of when expressions denote values or nothing. There is no direct contradiction, but the rules reflect an evolution in the specification that could cause confusion when comparing versions.",
    "affected_scenarios": [
      "Interpretation of expressions that are method invocations of void methods",
      "Determining whether an expression denotes a value or nothing during method resolution"
    ],
    "resolution_needed": "Clarify in the specification the evolution of the concept of expression denotation across versions and explicitly state the current rule supersedes the older one to avoid confusion.",
    "detected_at": "2025-05-29T08:52:03.588130",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_1999_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The rule text is identical in both Java 8 and Java 24 specifications but appears under different sections and categories (METHOD_RESOLUTION vs COMPILATION_RULES). This indicates a possible reorganization or reclassification of the rule between versions rather than a contradiction or ambiguity in the rule itself.",
    "affected_scenarios": [
      "Understanding the context and application of the phrase 'if the expression denotes a variable or a value, we may speak simply of the value of the expression' when migrating or comparing Java 8 and Java 24 specifications."
    ],
    "resolution_needed": "Clarify the scope and category changes between versions to ensure consistent interpretation and application of the rule across Java versions.",
    "detected_at": "2025-05-29T08:52:18.353091",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_1_8",
    "rule2_id": "rule_2000_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) states that if an expression denotes a variable or a value, we may speak simply of the value of the expression, implying expressions generally denote values. Rule 2 (Java 24) explicitly states that an expression denotes nothing if and only if it is a void method invocation. This represents a refinement and clarification over time rather than a direct contradiction, indicating a change in the specification between Java versions regarding when expressions denote values or nothing.",
    "affected_scenarios": [
      "Evaluating expressions that are method invocations of void methods",
      "Determining whether expressions denote values or nothing in method resolution"
    ],
    "resolution_needed": "Clarify the evolution of the definition of 'denotes' across Java versions and explicitly state how void method invocations are treated in earlier versions to avoid confusion.",
    "detected_at": "2025-05-29T08:52:22.021987",
    "rule1_text": "In this context, if the expression denotes a variable or a value, we may speak simply of the value of the expression....",
    "rule2_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_2_8",
    "rule2_id": "rule_9_11",
    "rule1_version": "8",
    "rule2_version": "11",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Unknown",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The rule about applying value set conversion to the result of every expression producing a value is consistent in wording between Java 8 and Java 11. However, the scope is unspecified in Java 8 and explicitly stated as 'runtime' in Java 11, indicating a clarification or refinement rather than a contradiction. This represents a change in the specification between versions rather than a direct conflict.",
    "affected_scenarios": [
      "Evaluation of expressions producing float or double values at runtime where value set conversion is applied"
    ],
    "resolution_needed": "Clarify the intended scope in Java 8 and confirm that the runtime scope in Java 11 is a refinement rather than a change in behavior",
    "detected_at": "2025-05-29T08:55:34.298702",
    "rule1_text": "Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used....",
    "rule2_text": "Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used....",
    "common_entities": [
      "('§5.1.13', 'ORG')"
    ],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_2_8",
    "rule2_id": "rule_14_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "The first rule from Java 8 mandates that value set conversion (§5.1.13) is applied to the result of every expression producing a value, including when using float or double variables. The second rule from Java 17 clarifies that when an expression denotes a variable (an lvalue), the value of that variable is used if a value is required for further evaluation. While not directly contradictory, the Java 17 rule shifts focus to the evaluation semantics and the distinction between variables and values, potentially superseding or refining the earlier conversion requirement. This represents an evolution in specification rather than a direct conflict, but it may cause ambiguity in how and when value set conversion is applied in the context of variable denotation and evaluation.",
    "affected_scenarios": [
      "Evaluation of expressions involving float or double variables where value set conversion is expected",
      "Situations where an expression denotes a variable and a value is required for further evaluation"
    ],
    "resolution_needed": "Clarify how value set conversion (§5.1.13) interacts with the evaluation semantics of expressions denoting variables in Java 17 and later, explicitly stating whether the conversion is still applied as in Java 8 or if the evaluation rules supersede or modify this behavior.",
    "detected_at": "2025-05-29T08:55:50.006893",
    "rule1_text": "Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_2_8",
    "rule2_id": "rule_20_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "RULE 1 from Java 8 mandates that value set conversion (§5.1.13) is applied to the result of every expression producing a value, including when using float or double variables. RULE 2 from Java 21 redefines expression evaluation semantics by distinguishing when an expression denotes a variable (lvalue) versus a value, specifying that if a value is required, the variable's value is used. This represents a conceptual shift in how expression results are interpreted and handled between versions, potentially affecting how and when conversions are applied. The rules do not directly contradict but reflect an evolution in specification that may cause ambiguity or different behavior in expression evaluation and conversion application.",
    "affected_scenarios": [
      "Evaluation of expressions involving variables of type float or double where value set conversion is relevant",
      "Situations where an expression denotes a variable and a value is required for further evaluation",
      "Code relying on implicit conversions applied immediately after expression evaluation"
    ],
    "resolution_needed": "Clarify how value set conversion (§5.1.13) interacts with the updated evaluation and denotation rules in Java 21, specifically whether conversion is applied immediately after obtaining a variable's value or at a different stage, and reconcile the conceptual model of expression results between versions.",
    "detected_at": "2025-05-29T08:56:05.787749",
    "rule1_text": "Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_2_8",
    "rule2_id": "rule_607_11",
    "rule1_version": "8",
    "rule2_version": "11",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Unknown",
    "type": "SCOPE_CONFLICT",
    "severity": "LOW",
    "description": "Both rules state that value set conversion is applied to the result of every expression producing a value, including float or double variables. The only difference is that the Java 11 rule explicitly specifies the scope as 'runtime', whereas the Java 8 rule does not specify scope. This creates a minor scope conflict regarding when the conversion is applied, but the fundamental requirement remains consistent.",
    "affected_scenarios": [
      "Evaluation of expressions producing float or double values during compile-time vs runtime"
    ],
    "resolution_needed": "Clarification on whether value set conversion applies strictly at runtime or also at compile-time, to unify scope interpretation across versions.",
    "detected_at": "2025-05-29T09:21:22.304217",
    "rule1_text": "Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used....",
    "rule2_text": "Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used....",
    "common_entities": [
      "('§5.1.13', 'ORG')"
    ],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_2_8",
    "rule2_id": "rule_1981_11",
    "rule1_version": "8",
    "rule2_version": "11",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Unknown",
    "type": "VERSION_CHANGE",
    "severity": "LOW",
    "description": "The rule about applying value set conversion to the result of every expression producing a value, including float or double variables, is present in both Java 8 and Java 11 specifications. However, the Java 11 rule explicitly specifies the scope as 'runtime', whereas the Java 8 rule does not specify scope. This indicates a change or clarification in the rule's application context between versions, but does not create a direct contradiction or ambiguity.",
    "affected_scenarios": [
      "Evaluation of expressions involving float or double variables at runtime"
    ],
    "resolution_needed": "Clarify whether the absence of scope in Java 8 implies a different or broader application than the explicit 'runtime' scope in Java 11, to avoid confusion about when value set conversion is applied.",
    "detected_at": "2025-05-29T10:16:59.454381",
    "rule1_text": "Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used....",
    "rule2_text": "Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used....",
    "common_entities": [
      "('§5.1.13', 'ORG')"
    ],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_2_8",
    "rule2_id": "rule_2078_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "18",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 18. Type Inference",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 18. Type Inference",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "RULE 1 from Java 8 mandates that value set conversion (§5.1.13) shall be applied to the result of every expression producing a value, establishing a strict type compatibility requirement. RULE 2 from Java 21 introduces a more permissive notion of compatibility ('may be compatible in a loose invocation context'), indicating a relaxation or evolution in type compatibility rules. This represents a change in how type compatibility is treated between Java versions rather than a direct contradiction or ambiguity. The difference in modality ('shall' vs 'may') and context (general expression evaluation vs loose invocation context) reflects an evolution in the specification.",
    "affected_scenarios": [
      "Type compatibility checks during method invocation in Java 21 where loose invocation context compatibility is considered",
      "Expression evaluation and value conversion in Java 8 where strict value set conversion is applied"
    ],
    "resolution_needed": "Clarify how value set conversion requirements from earlier Java versions relate to or are superseded by the looser compatibility rules introduced in Java 21, especially in invocation contexts.",
    "detected_at": "2025-05-29T10:20:25.789289",
    "rule1_text": "Value set conversion ( §5.1.13 ) is applied to the result of every expression that produces a value, including when the value of a variable of type float or double is used....",
    "rule2_text": "The formulas may take one of the following forms: ‹ Expression → T ›: An expression is compatible in a loose invocation context with type T ( §5.3 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-18.html",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_14_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 from Java 8 states that an expression denotes nothing if and only if it is a method invocation of a void method, establishing a strict equivalence. Rule 2 from Java 17 expands the denotation categories to three: variable, value, or nothing (void), and introduces the concept that if an expression denotes a variable but a value is required, the variable's value is used. This represents an evolution in the specification, broadening the understanding of expression denotation beyond the strict void method invocation case. The change may cause confusion when reasoning about expressions that denote variables or values, as the earlier rule's 'if and only if' condition no longer fully captures all cases of 'denotes nothing'.",
    "affected_scenarios": [
      "Evaluating expressions that are method invocations of void methods",
      "Expressions that denote variables but are used in value contexts",
      "General interpretation of what it means for an expression to denote 'nothing'"
    ],
    "resolution_needed": "Clarify the relationship between the strict 'if and only if' void method invocation condition and the broader three-category denotation model introduced in later versions, including how to interpret expressions that denote variables or values in contexts requiring values.",
    "detected_at": "2025-05-29T10:21:59.541473",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_17_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) states that an expression denotes nothing if and only if it is a method invocation of a void method, implying that method invocations returning a value always denote a value. Rule 2 (Java 17) clarifies that an expression statement or lambda body that is a method invocation may invoke a method that returns a value, but the returned value is discarded. This represents an evolution in the specification between Java 8 and Java 17, reflecting a change in how method invocation expressions are treated in expression statements or lambda bodies. There is no direct contradiction, but the understanding of 'denotes nothing' has been extended to allow discarding returned values in certain contexts.",
    "affected_scenarios": [
      "Expression statements invoking methods that return a value",
      "Lambda bodies invoking methods that return a value"
    ],
    "resolution_needed": "Clarify in the specification how 'denotes nothing' applies in expression statements and lambda bodies when invoking methods that return values, explicitly reconciling the Java 8 and Java 17 perspectives.",
    "detected_at": "2025-05-29T10:22:12.166632",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_20_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) states that an expression denotes nothing if and only if it is a method invocation of a void method, implying a strict equivalence. Rule 2 (Java 21) expands the denotation of expressions to three categories: variable, value, or nothing (void), and introduces the concept that expressions denoting variables can yield values when needed. This represents a conceptual broadening and refinement of expression denotation between versions, potentially changing how 'denotes nothing' is interpreted and applied.",
    "affected_scenarios": [
      "Determining the denotation of expressions involving void method invocations and variable expressions during evaluation and compilation"
    ],
    "resolution_needed": "Clarify how the 'denotes nothing' condition from Java 8 maps to the three-category denotation model in Java 21, and specify how expressions that denote variables but require values interact with void method invocations.",
    "detected_at": "2025-05-29T10:22:23.640912",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_23_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) states that an expression denotes nothing if and only if it is a method invocation of a void method, implying that method invocations returning a value always denote a value. Rule 2 (Java 21) clarifies that an expression statement or lambda body that is a method invocation may invoke a method that returns a value, but the returned value is discarded. This represents a change in the language semantics between versions, where method invocations returning values can be used in expression statements with their results ignored, which was not explicitly allowed or described in Java 8. The rules do not directly contradict but reflect an evolution in the language specification.",
    "affected_scenarios": [
      "Expression statements invoking methods that return values",
      "Lambda bodies invoking methods that return values"
    ],
    "resolution_needed": "Clarify the treatment of method invocations returning values in expression statements and lambda bodies across Java versions, explicitly stating when returned values are considered to denote nothing.",
    "detected_at": "2025-05-29T10:22:33.587511",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_26_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 from Java 8 states that an expression denotes nothing if and only if it is a method invocation of a void method, establishing a strict equivalence. Rule 2 from a later Java version (Java 24) expands the denotation categories to three: variable, value, or nothing (void), and introduces the concept that if an expression denotes a variable but a value is required, the variable's value is used. This represents an evolution in the specification, broadening the understanding of expression denotation beyond the Java 8 definition. The difference in definitions and scope between the two versions can cause confusion when reasoning about expression denotation across versions.",
    "affected_scenarios": [
      "Interpreting expression denotation in codebases or tools that mix Java 8 and later Java specifications",
      "Static analysis or compiler implementations that rely on the strict 'void method invocation' equivalence for 'denotes nothing' from Java 8",
      "Runtime evaluation semantics where the expanded categories of denotation (variable, value, nothing) affect expression handling"
    ],
    "resolution_needed": "Clarify the evolution of expression denotation semantics across Java versions, explicitly documenting how the Java 8 rule maps to or is superseded by the later rule, and provide guidance for tools and developers on handling these differences.",
    "detected_at": "2025-05-29T10:22:45.063465",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_29_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.12",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) states that an expression denotes nothing if and only if it is a method invocation of a void method, implying only void methods produce no value. Rule 2 (Java 24) expands this by allowing method invocations that return a value to be used as expression statements or lambda bodies where the returned value is discarded. This represents a change in the language semantics between versions, where non-void method invocations can also be treated as expressions denoting nothing in certain contexts. The rules do not directly contradict but reflect an evolution in the language specification.",
    "affected_scenarios": [
      "Expression statements invoking non-void methods where the returned value is discarded",
      "Lambda bodies invoking methods that return a value but whose result is ignored"
    ],
    "resolution_needed": "Clarify the evolution of expression denotation semantics across Java versions and explicitly document contexts where non-void method invocations denote nothing due to discarded results.",
    "detected_at": "2025-05-29T10:22:53.526427",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_609_11",
    "rule1_version": "8",
    "rule2_version": "11",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Unknown",
    "type": "CONTRADICTION",
    "severity": "MEDIUM",
    "description": "Rule 1 states that an expression denotes nothing if and only if it is a method invocation of a void method, implying that method invocations returning a value always denote something. Rule 2, however, states that an expression statement or lambda body that is a method invocation may invoke a method that returns a value, but the returned value is discarded, effectively making the expression denote nothing in that context. This creates a direct contradiction about whether method invocations returning values can denote nothing.",
    "affected_scenarios": [
      "Expression statements invoking methods that return a value",
      "Lambda bodies invoking methods that return a value"
    ],
    "resolution_needed": "Clarify the distinction between 'expression denotes nothing' in general expressions versus expression statements or lambda bodies, and explicitly state how returned values are treated in these contexts.",
    "detected_at": "2025-05-29T10:45:26.119863",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_612_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 from Java 8 states that an expression denotes nothing if and only if it is a method invocation of a void method, establishing a strict equivalence. Rule 2 from Java 17 expands the concept of what an expression can denote at runtime to three categories: a variable, a value, or nothing (void). This broadens the denotation beyond just void method invocations to include variables and values, reflecting an evolution in the language specification. The change implies that the strict 'if and only if' condition from Java 8 no longer fully captures the runtime denotation semantics in Java 17, indicating a version-based change rather than a direct contradiction.",
    "affected_scenarios": [
      "Evaluating expressions that are not method invocations but still denote nothing (void) in Java 17",
      "Interpreting the meaning of 'denotes nothing' in expressions across Java 8 and Java 17"
    ],
    "resolution_needed": "Clarify the evolution of expression denotation semantics between Java 8 and Java 17, explicitly stating how the 'if and only if' condition from Java 8 relates to the broader runtime denotation categories introduced in Java 17.",
    "detected_at": "2025-05-29T10:45:38.665555",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_615_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) states that an expression denotes nothing if and only if it is a method invocation of a void method, implying that method invocations returning a value always denote a value. Rule 2 (Java 17) clarifies that expression statements or lambda bodies invoking methods that return a value may discard the returned value, effectively treating such expressions as denoting nothing in those contexts. This represents a change in the language specification between Java 8 and Java 17 regarding the treatment of method invocations returning values in expression statements or lambda bodies.",
    "affected_scenarios": [
      "Expression statements invoking methods that return a value",
      "Lambda bodies invoking methods that return a value"
    ],
    "resolution_needed": "Clarify the treatment of method invocations returning values in expression statements and lambda bodies, explicitly reconciling the 'denotes nothing' concept with value discarding in later Java versions.",
    "detected_at": "2025-05-29T10:45:47.911657",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_618_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 from Java 8 states that an expression denotes nothing if and only if it is a method invocation of a void method, implying a strict equivalence. Rule 2 from Java 21 expands the denotation categories to three: variable, value, or nothing (void), and introduces the concept that expressions can denote variables or values, not just nothing or void. This represents a conceptual evolution in the language specification, changing the understanding of what expressions denote. While not a direct contradiction, it changes the criteria and scope of 'denotes nothing' from a strict if-and-only-if condition to part of a broader classification, indicating a version change in the specification.",
    "affected_scenarios": [
      "Determining whether an expression denotes nothing during compilation and runtime evaluation",
      "Method invocation expressions returning void versus other expressions denoting variables or values",
      "Semantic analysis of expressions in tools or compilers targeting different Java versions"
    ],
    "resolution_needed": "Clarify the evolution of the denotation concept across Java versions and explicitly document how the if-and-only-if condition from Java 8 relates to the broader classification in Java 21, including any transitional or backward compatibility considerations.",
    "detected_at": "2025-05-29T10:45:58.974366",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_621_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) states that an expression denotes nothing if and only if it is a method invocation of a void method, implying that method invocations returning values always denote something. Rule 2 (Java 21) clarifies that method invocations returning values can appear as expression statements or lambda bodies where their returned values are discarded without error. This represents an evolution in the specification allowing method invocations with return values to be used in expression statements by discarding their results, which was not explicitly allowed or described in Java 8. The rules do not directly contradict but reflect a change in language semantics between versions.",
    "affected_scenarios": [
      "Expression statements invoking methods that return values",
      "Lambda bodies invoking methods that return values"
    ],
    "resolution_needed": "Clarify in the specification the transition from Java 8 to Java 21 regarding the treatment of method invocations with return values in expression statements and lambda bodies, explicitly stating that discarding returned values is permitted and how this affects the notion of 'denotes nothing'.",
    "detected_at": "2025-05-29T10:46:09.671561",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_624_24",
    "rule1_version": "8",
    "rule2_version": "24",
    "rule1_section": "15.12",
    "rule2_section": "15.12.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 15. Expressions",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "RULE 1 from Java 8 states that an expression denotes nothing if and only if it is a method invocation of a void method, establishing a strict equivalence. RULE 2 from a later Java version (Java 24) expands the denotation of expressions to three categories: variable, value, or nothing (void), without limiting 'nothing' solely to void method invocations. This represents a change in the language specification between versions, potentially altering how expressions that denote nothing are identified and handled.",
    "affected_scenarios": [
      "Expressions that denote nothing but are not method invocations of void methods (e.g., explicit void expressions or other constructs introduced or clarified in later versions)",
      "Method invocations of void methods where the interpretation of 'denotes nothing' might differ due to expanded categories"
    ],
    "resolution_needed": "Clarify the evolution of the definition of expressions denoting nothing across Java versions and specify how expressions that denote nothing are identified in the latest specification to avoid confusion between versions.",
    "detected_at": "2025-05-29T10:46:19.054820",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-15.12.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_1161_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "15.12",
    "rule2_section": "8.4.3",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 8. Classes",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 8. Classes",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 from Java 8 defines when an expression denotes nothing based on method invocation of void methods, without restrictions on unqualified instance method invocations. Rule 2 from Java 17 prohibits unqualified invocations of instance methods of lexically enclosing classes or interfaces at compile-time, effectively restricting certain method invocations that would otherwise be allowed in Java 8. This represents a change in allowed method invocation forms between versions, potentially affecting code that was valid in Java 8 but disallowed in Java 17.",
    "affected_scenarios": [
      "Unqualified invocation of instance methods of lexically enclosing classes/interfaces that return void",
      "Code relying on void method invocations without qualification in nested classes"
    ],
    "resolution_needed": "Clarify the evolution of method invocation rules across Java versions and explicitly document the prohibition of unqualified instance method invocations in later versions to avoid confusion.",
    "detected_at": "2025-05-29T11:02:33.735064",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.4.3",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_1275_21",
    "rule1_version": "8",
    "rule2_version": "21",
    "rule1_section": "15.12",
    "rule2_section": "8.4.3",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Chapter 8. Classes",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 8. Classes",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 from Java 8 defines that expressions denoting method invocations of void methods denote nothing, implying such invocations are valid and meaningful expressions. Rule 2 from Java 21 prohibits unqualified invocations of instance methods of any lexically enclosing class or interface, effectively restricting certain method invocations that were previously allowed. This represents a change in the language specification between versions, potentially invalidating some expressions that were valid in Java 8. There is no direct contradiction or ambiguity, but the rules reflect an evolution in method invocation constraints.",
    "affected_scenarios": [
      "Unqualified invocation of instance methods of lexically enclosing classes/interfaces that return void",
      "Expressions invoking void methods unqualifiedly in nested classes/interfaces"
    ],
    "resolution_needed": "Clarification on how expressions invoking void methods in lexically enclosing contexts should be treated in Java 21 and later, especially regarding the validity and denotation of such expressions.",
    "detected_at": "2025-05-29T11:07:08.308571",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 )....",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.3",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_3_8",
    "rule2_id": "rule_1979_11",
    "rule1_version": "8",
    "rule2_version": "11",
    "rule1_section": "15.12",
    "rule2_section": "15.10.2",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Unknown",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Rule 1 (Java 8) states that an expression denotes nothing if and only if it is a method invocation of a void method, implying a strict equivalence. Rule 2 (Java 11) expands the concept of what an expression can denote at runtime to three categories: a variable, a value, or nothing (void). This represents a conceptual evolution in the language specification, broadening the understanding of expression denotation beyond just void method invocations. The difference in modality and scope between compile-time (Rule 1) and runtime (Rule 2) also reflects a change in how expression evaluation is described across versions.",
    "affected_scenarios": [
      "Determining the denotation of expressions involving void method invocations",
      "Runtime evaluation of expressions that do not invoke void methods but still denote nothing",
      "Compiler and runtime behavior consistency regarding expression denotation"
    ],
    "resolution_needed": "Clarify the relationship and transition between compile-time and runtime expression denotation rules across Java versions, explicitly addressing how void method invocations fit into the broader runtime model of expression denotation.",
    "detected_at": "2025-05-29T11:33:51.941845",
    "rule1_text": "An expression denotes nothing if and only if it is a method invocation ( §15.12 ) that invokes a method that does not return a value, that is, a method declared void ( §8.4 )....",
    "rule2_text": "Evaluation, Denotation, and Result When an expression in a program is evaluated ( executed ), the result denotes one of three things: A variable ( §4.12 ) (in C, this would be called an lvalue ) A val...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.10.2",
    "call_limit_exceeded": false
  },
  {
    "rule1_id": "rule_50_8",
    "rule2_id": "rule_200_17",
    "rule1_version": "8",
    "rule2_version": "17",
    "rule1_section": "14.11",
    "rule2_section": "14.11",
    "rule1_section_title": "Unknown",
    "rule2_section_title": "Unknown",
    "rule1_chapter": "Unknown",
    "rule2_chapter": "Chapter 14. Blocks, Statements, and Patterns",
    "type": "VERSION_CHANGE",
    "severity": "MEDIUM",
    "description": "Java 17 expands the rule in two ways: (1) adds the 'yield' statement as another control transfer mechanism, and (2) broadens the scope from just 'statements' to 'expressions, statements, and blocks'. This is an intentional evolution of the language specification rather than a conflict, but it represents a notable change in behavior between versions.",
    "affected_scenarios": [
      "Switch expressions using yield statements in Java 17",
      "Control flow analysis involving expressions and blocks in Java 17",
      "Code that needs to be compatible across Java 8 and 17"
    ],
    "resolution_needed": "Code written for Java 8 that needs to run on Java 17 should be reviewed for potential impact of the expanded rule, particularly in switch expressions and when analyzing control flow. However, this is a backward-compatible change that doesn't break existing code.",
    "detected_at": "2025-05-27T06:10:16.835931",
    "rule1_text": "However, certain events may prevent a statement from completing normally: The break ( §14.15 ), continue ( §14.16 ), and return ( §14.17 ) statements cause a transfer of control that may prevent norma...",
    "rule2_text": "However, certain events may prevent a statement from completing normally: The break , yield , continue , and return statements ( §14.15 , §14.21 , §14.16 , §14.17 ) cause a transfer of control that ma...",
    "common_entities": [],
    "rule1_url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-14.11",
    "rule2_url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-15.html#jls-14.11",
    "call_limit_exceeded": false
  }
]