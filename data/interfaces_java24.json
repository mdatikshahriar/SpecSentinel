{
  "text": "9.1. Interface Declarations An interface declaration specifies an interface. There are two kinds of interface declarations: normal interface declarations and annotation interface declarations ( §9.6 ). InterfaceDeclaration: NormalInterfaceDeclaration AnnotationInterfaceDeclaration NormalInterfaceDeclaration: { InterfaceModifier } interface TypeIdentifier [ TypeParameters ] [ InterfaceExtends ] [ InterfacePermits ] InterfaceBody The TypeIdentifier in an interface declaration specifies the name of the interface. It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of an interface declaration is specified in §6.3 and §6.4.1 . 9.1.1. Interface Modifiers An interface declaration may include interface modifiers . InterfaceModifier: (one of) Annotation public protected private abstract static sealed non-sealed strictfp The rules concerning annotation modifiers for an interface declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level interfaces ( §7.6 ) and member interfaces ( §8.5 , §9.5 ), not to local interfaces ( §14.3 ). The access modifiers protected and private pertain only to member interfaces. The modifier static pertains only to member interfaces and local interfaces. It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration, or if a interface declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if an interface declaration has more than one of the modifiers sealed and non-sealed . If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier . 9.1.1.1. abstract Interfaces Every interface is implicitly abstract . This modifier is obsolete and should not be used in new code. 9.1.1.2. strictfp Interfaces The strictfp modifier on an interface declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 9.1.1.3. static Interfaces A nested interface is implicitly static . That is, every member interface and local interface is static . It is permitted for the declaration of a member interface to redundantly specify the static modifier ( §9.5 ), but it is not permitted for the declaration of a local interface ( §14.3 ). Because a nested interface is static , it has no immediately enclosing instance ( §8.1.3 ). References from a nested interface to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods in lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , §15.12.3 ). 9.1.1.4. sealed and non-sealed Interfaces An interface can be declared sealed if all its direct subclasses and direct subinterfaces are known when the interface is declared ( §9.1.4 ), and no other direct subclasses or direct subinterfaces are desired or required. It is useful to recall that a class is said to be a direct subclass of its direct superinterfaces ( §8.1.5 ). An interface is freely extensible if none of its direct superinterfaces are sealed ( §9.1.3 ), and it is not sealed itself. An interface that has a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if an interface has a sealed direct superinterface and is not declared sealed or non-sealed . It is a compile-time error if an interface is declared non-sealed but has no sealed direct superinterface. 9.1.2. Generic Interfaces and Type Parameters An interface is generic if the interface declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the interface. The type parameter section follows the interface name and is delimited by angle brackets. The following productions from §8.1.2 and §4.4 are shown here for convenience: TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In an interface's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself. The scope and shadowing of an interface's type parameter is specified in §6.3 and §6.4.1 . References to an interface's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic interface declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time. 9.1.3. Superinterfaces and Subinterfaces If an extends clause is provided, then the interface being declared extends each of the specified interface types and therefore inherits the member classes, member interfaces, instance methods, and static fields of each of those interface types. The specified interface types are the direct superinterface types of the interface being declared. Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends . InterfaceExtends: extends InterfaceTypeList The following production from §8.1.5 is shown here for convenience: InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType in the extends clause of an interface declaration must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the interface being declared is not a permitted direct subinterface of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. One interface is a direct superinterface of another interface if the first interface is named by one of the direct superinterface types of the second interface. The superinterface relationship is the transitive closure of the direct superinterface relationship. An interface I is a superinterface of interface K if either of the following is true: I is a direct superinterface of K . Where J is a direct superinterface of K , I is a superinterface of J , applying this definition recursively. An interface is said to be a direct subinterface of its direct superinterface, and a subinterface of each of its superinterfaces. While every class is an extension of class Object , there is no single interface of which all interfaces are extensions. An interface I directly depends on a class or interface A if A is mentioned in the extends clause of I either as a superinterface or as a qualifier in the fully qualified form of a superinterface name. An interface I depends on a class or interface A if any of the following is true: I directly depends on A . I directly depends on a class C that depends on A ( §8.1.5 ). I directly depends on an interface J that depends on A , applying this definition recursively. It is a compile-time error if an interface depends on itself. If circularly declared interfaces are detected at run time, as interfaces are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). 9.1.4. Permitted Direct Subclasses and Subinterfaces The optional permits clause in a normal interface declaration specifies all the classes and interfaces intended as direct subclasses and direct subinterfaces of the interface being declared ( §9.1.1.4 ). InterfacePermits: permits TypeName { , TypeName } It is a compile-time error if an interface declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class or interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class or interface is specified more than once in a permits clause. This is true even if the class or interface is named in different ways. The canonical name of a class or interface does not need to be used in a permits clause, but a permits clause can only specify a class or interface once. For example, the following program fails to compile: package p; sealed interface I permits C, D, p.C {} // error non-sealed class C implements I {} non-sealed class D implements I {} If a sealed interface I is associated with a named module ( §7.3 ), then every class or interface specified in the permits clause of I 's declaration must be associated with the same module as I , or a compile-time error occurs. If a sealed interface I is associated with an unnamed module ( §7.7.5 ), then every class or interface specified in the permits clause of I 's declaration must belong to the same package as I , or a compile-time error occurs. A sealed interface and its direct subclasses and direct subinterfaces need to refer to each other in a circular fashion, in permits , implements , and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes and interfaces in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed interface hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed interface I has a permits clause, then the permitted direct subclasses and subinterfaces of I are the classes and interfaces specified by the permits clause. Every permitted direct subclass and subinterface specified by the permits clause must be a direct subclass of I ( §8.1.5 ) or a direct subinterface of I ( §9.1.3 ), or a compile-time error occurs. If the declaration of a sealed interface I lacks a permits clause, then the permitted direct subclasses and subinterfaces of I are those classes and interfaces declared in the same compilation unit as I ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superinterfaces include I . That is, the permitted direct subclasses and subinterfaces are inferred as the classes and interfaces in the same compilation unit that specify I as a direct superinterface. The requirement for a canonical name means that no local classes, local interfaces, or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed interface I lacks a permits clause and I has no permitted direct subclasses or subinterfaces. 9.1.5. Interface Body and Member Declarations An interface body may contain declarations of members of the interface, that is, fields ( §9.3 ), methods ( §9.4 ), classes, and interfaces ( §9.5 ). InterfaceBody: { { InterfaceMemberDeclaration } } InterfaceMemberDeclaration: ConstantDeclaration InterfaceMethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope of a declaration of a member m declared in or inherited by an interface I is specified in §6.3 .",
  "metadata": {
    "java_version": "24",
    "section_number": "9",
    "section_title": "Chapter 9. Interfaces",
    "chapter_title": "Chapter 9. Interfaces"
  },
  "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-9.html",
  "section_name": "interfaces",
  "downloaded_at": "2025-05-27T13:20:29.659648"
}