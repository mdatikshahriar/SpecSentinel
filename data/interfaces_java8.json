{
  "text": "9.1. Interface Declarations An interface declaration specifies a new named reference type. There are two kinds of interface declarations - normal interface declarations and annotation type declarations ( §9.6 ). InterfaceDeclaration: NormalInterfaceDeclaration AnnotationTypeDeclaration NormalInterfaceDeclaration: { InterfaceModifier } interface Identifier [ TypeParameters ] [ ExtendsInterfaces ] InterfaceBody The Identifier in an interface declaration specifies the name of the interface. It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of an interface declaration is specified in §6.3 and §6.4 . 9.1.1. Interface Modifiers An interface declaration may include interface modifiers . InterfaceModifier: (one of) Annotation public protected private abstract static strictfp The rules for annotation modifiers on an interface declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains to every kind of interface declaration. The access modifiers protected and private pertain only to member interfaces whose declarations are directly enclosed by a class declaration ( §8.5.1 ). The modifier static pertains only to member interfaces ( §8.5.1 , §9.5 ), not to top level interfaces ( §7.6 ). It is a compile-time error if the same keyword appears more than once as a modifier for an interface declaration. If two or more (distinct) interface modifiers appear in an interface declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for InterfaceModifier . 9.1.1.1. abstract Interfaces Every interface is implicitly abstract . This modifier is obsolete and should not be used in new programs. 9.1.1.2. strictfp Interfaces The effect of the strictfp modifier is to make all float or double expressions within the interface declaration be explicitly FP-strict ( §15.4 ). This implies that all methods declared in the interface, and all nested types declared in the interface, are implicitly strictfp . 9.1.2. Generic Interfaces and Type Parameters An interface is generic if it declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the interface. The type parameter section follows the interface name and is delimited by angle brackets. The following productions from §8.1.2 and §4.4 are shown here for convenience: TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } TypeParameter: { TypeParameterModifier } Identifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules for annotation modifiers on a type parameter declaration are specified in §9.7.4 and §9.7.5 . In an interface's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a interface's type parameter section depends on itself. The scope and shadowing of an interface's type parameter is specified in §6.3 . It is a compile-time error to refer to a type parameter of an interface I anywhere in the declaration of a field or type member of I . A generic interface declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same interface at run time. 9.1.3. Superinterfaces and Subinterfaces If an extends clause is provided, then the interface being declared extends each of the other named interfaces and therefore inherits the member types, methods, and constants of each of the other named interfaces. These other named interfaces are the direct superinterfaces of the interface being declared. Any class that implements the declared interface is also considered to implement all the interfaces that this interface extends . ExtendsInterfaces: extends InterfaceTypeList The following production from §8.1.5 is shown here for convenience: InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType in the extends clause of an interface declaration must name an accessible interface type ( §6.6 ), or a compile-time error occurs. If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. Given a (possibly generic) interface declaration I < F 1 ,..., F n > ( n ≥ 0), the direct superinterfaces of the interface type I < F 1 ,..., F n > are the types given in the extends clause of the declaration of I , if an extends clause is present. Given a generic interface declaration I < F 1 ,..., F n > ( n > 0), the direct superinterfaces of the parameterized interface type I < T 1 ,..., T n > , where T i (1 ≤ i ≤ n ) is a type, are all types J < U 1 θ ,..., U k θ > , where J < U 1 ,..., U k > is a direct superinterface of I < F 1 ,..., F n > and θ is the substitution [ F 1 := T 1 ,..., F n := T n ] . The superinterface relationship is the transitive closure of the direct superinterface relationship. An interface K is a superinterface of interface I if either of the following is true: K is a direct superinterface of I . There exists an interface J such that K is a superinterface of J , and J is a superinterface of I , applying this definition recursively. Interface I is said to be a subinterface of interface K whenever K is a superinterface of I . While every class is an extension of class Object , there is no single interface of which all interfaces are extensions. An interface I directly depends on a type T if T is mentioned in the extends clause of I either as a superinterface or as a qualifier in the fully qualified form of a superinterface name. An interface I depends on a reference type T if any of the following is true: I directly depends on T . I directly depends on a class C that depends on T ( §8.1.5 ). I directly depends on an interface J that depends on T (using this definition recursively). It is a compile-time error if an interface depends on itself. If circularly declared interfaces are detected at run time, as interfaces are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). 9.1.4. Interface Body and Member Declarations The body of an interface may declare members of the interface, that is, fields ( §9.3 ), methods ( §9.4 ), classes ( §9.5 ), and interfaces ( §9.5 ). InterfaceBody: { { InterfaceMemberDeclaration } } InterfaceMemberDeclaration: ConstantDeclaration InterfaceMethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope of a declaration of a member m declared in or inherited by an interface type I is specified in §6.3 .",
  "metadata": {
    "java_version": "8",
    "section_number": "9",
    "section_title": "Chapter 9. Interfaces",
    "chapter_title": "Unknown"
  },
  "url": "https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html",
  "section_name": "interfaces",
  "downloaded_at": "2025-05-27T13:20:23.340868"
}