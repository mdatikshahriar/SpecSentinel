{
  "text": "8.1. Class Declarations A class declaration specifies a class. There are three kinds of class declarations: normal class declarations , enum declarations ( §8.9 ), and record declarations ( §8.10 ). ClassDeclaration: NormalClassDeclaration EnumDeclaration RecordDeclaration NormalClassDeclaration: { ClassModifier } class TypeIdentifier [ TypeParameters ] [ ClassExtends ] [ ClassImplements ] [ ClassPermits ] ClassBody A class is also implicitly declared by a class instance creation expression ( §15.9.5 ) and an enum constant that ends with a class body ( §8.9.1 ). The TypeIdentifier in a class declaration specifies the name of the class. It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces. The scope and shadowing of a class declaration is specified in §6.3 and §6.4.1 . 8.1.1. Class Modifiers A class declaration may include class modifiers . ClassModifier: (one of) Annotation public protected private abstract static final sealed non-sealed strictfp The rules concerning annotation modifiers for a class declaration are specified in §9.7.4 and §9.7.5 . The access modifier public ( §6.6 ) pertains only to top level classes ( §7.6 ) and member classes ( §8.5 , §9.5 ), not to local classes ( §14.3 ) or anonymous classes ( §15.9.5 ). The access modifiers protected and private pertain only to member classes. The modifier static pertains only to member classes and local classes. It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers public , protected , and private . It is a compile-time error if a class declaration has more than one of the modifiers sealed , non-sealed , and final . If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for ClassModifier . 8.1.1.1. abstract Classes An abstract class is a class that is incomplete, or to be considered incomplete. It is a compile-time error if an attempt is made to create an instance of an abstract class using a class instance creation expression ( §15.9.1 ). A subclass of an abstract class that is not itself abstract may be instantiated, resulting in the execution of a constructor for the abstract class and, therefore, the execution of the field initializers for instance variables of that class. A normal class may have abstract methods, that is, methods that are declared but not yet implemented ( §8.4.3.1 ), only if it is an abstract class. It is a compile-time error if a normal class that is not abstract has an abstract method. A class C has abstract methods if either of the following is true: Any of the member methods ( §8.2 ) of C - either declared or inherited - is abstract . Any of C 's superclasses has an abstract method declared with package access, and there exists no method that overrides the abstract method from C or from a superclass of C . It is a compile-time error to declare an abstract class type such that it is not possible to create a subclass that implements all of its abstract methods. This situation can occur if the class would have as members two abstract methods that have the same method signature ( §8.4.2 ) but return types for which no type is return-type-substitutable with both ( §8.4.5 ). Example 8.1.1.1-1. Abstract Class Declaration abstract class Point { int x = 1, y = 1; void move(int dx, int dy) { x += dx; y += dy; alert(); } abstract void alert(); } abstract class ColoredPoint extends Point { int color; } class SimplePoint extends Point { void alert() { } } Here, a class Point is declared that must be declared abstract , because it contains a declaration of an abstract method named alert . The subclass of Point named ColoredPoint inherits the abstract method alert , so it must also be declared abstract . On the other hand, the subclass of Point named SimplePoint provides an implementation of alert , so it need not be abstract . The statement: Point p = new Point(); would result in a compile-time error; the class Point cannot be instantiated because it is abstract . However, a Point variable could correctly be initialized with a reference to any subclass of Point , and the class SimplePoint is not abstract , so the statement: Point p = new SimplePoint(); would be correct. Instantiation of a SimplePoint causes the default constructor and field initializers for x and y of Point to be executed. Example 8.1.1.1-2. Abstract Class Declaration that Prohibits Subclasses interface Colorable { void setColor(int color); } abstract class Colored implements Colorable { public abstract int setColor(int color); } These declarations result in a compile-time error: it would be impossible for any subclass of class Colored to provide an implementation of a method named setColor , taking one argument of type int , that can satisfy both abstract method specifications, because the one in interface Colorable requires the same method to return no value, while the one in class Colored requires the same method to return a value of type int ( §8.4 ). A class type should be declared abstract only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor ( §8.8.10 ) of no arguments, make it private , never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class Math is an example of a class that cannot be instantiated; its declaration looks like this: public final class Math { private Math() { } // never instantiate this class . . . declarations of class variables and methods . . . } 8.1.1.2. sealed , non-sealed , and final Classes A class can be declared sealed if all its direct subclasses are known when the class is declared ( §8.1.6 ), and no other direct subclasses are desired or required. Explicit and exhaustive control over a class's direct subclasses is useful when the class hierarchy is used to model the kinds of values in a domain, rather than as a mechanism for code inheritance and reuse. The direct subclasses may themselves be declared sealed in order to further control the class hierarchy. A class can be declared final if its definition is complete and no subclasses are desired or required. It is a compile-time error if a class is declared both final and abstract , because the implementation of such a class could never be completed ( §8.1.1.1 ). Because a final class never has any subclasses, the methods of a final class are never overridden ( §8.4.8.1 ). A class is freely extensible if its direct superclass is not sealed ( §8.1.4 ), and none of its direct superinterfaces are sealed ( §8.1.5 ), and it is neither sealed nor final itself. A class that has a sealed direct superclass or a sealed direct superinterface is freely extensible if and only if it is declared non-sealed . It is a compile-time error if a class has a sealed direct superclass or a sealed direct superinterface, and is not declared final , sealed , or non-sealed either explicitly or implicitly. Thus, an effect of the sealed keyword is to force all direct subclasses to explicitly declare whether they are final , sealed , or non-sealed . This avoids accidentally exposing a sealed class hierarchy to unwanted subclassing. An enum class is either implicitly final or implicitly sealed , so it can implement a sealed interface. Similarly, a record class is implicitly final , so it can also implement a sealed interface. It is a compile-time error if a class is declared non-sealed but has neither a sealed direct superclass nor a sealed direct superinterface. Thus, a subclass of a non-sealed class cannot itself be declared non-sealed . 8.1.1.3. strictfp Classes The strictfp modifier on a class declaration is obsolete and should not be used in new code. Its presence or absence has no effect at compile time or run time. 8.1.1.4. static Classes The static modifier specifies that a nested class is not an inner class ( §8.1.3 ). Just as a static method of a class has no current instance of the class in its body, a static nested class has no immediately enclosing instance in its body. References from a static nested class to type parameters, instance variables, local variables, formal parameters, exception parameters, or instance methods of lexically enclosing class, interface, or method declarations are disallowed ( §6.5.5.1 , §6.5.6.1 , and §15.12.3 ). The static modifier does not pertain to all nested classes. It pertains only to member classes, whose declarations may use the static modifier, and not to local classes or anonymous classes, whose declarations may not use the static modifier ( §14.3 , §15.9.5 ). However, some local classes are implicitly static , namely local enum classes and local record classes, because all nested enum classes and nested record classes are implicitly static ( §8.9 , §8.10 ). 8.1.2. Generic Classes and Type Parameters A class is generic if the class declaration declares one or more type variables ( §4.4 ). These type variables are known as the type parameters of the class. The type parameter section follows the class name and is delimited by angle brackets. TypeParameters: < TypeParameterList > TypeParameterList: TypeParameter { , TypeParameter } The following productions from §4.4 are shown here for convenience: TypeParameter: { TypeParameterModifier } TypeIdentifier [ TypeBound ] TypeParameterModifier: Annotation TypeBound: extends TypeVariable extends ClassOrInterfaceType { AdditionalBound } AdditionalBound: & InterfaceType The rules concerning annotation modifiers for a type parameter declaration are specified in §9.7.4 and §9.7.5 . In a class's type parameter section, a type variable T directly depends on a type variable S if S is the bound of T , while T depends on S if either T directly depends on S or T directly depends on a type variable U that depends on S (using this definition recursively). It is a compile-time error if a type variable in a class's type parameter section depends on itself. The scope and shadowing of a class's type parameter is specified in §6.3 and §6.4.1 . References to a class's type parameter from a static context or a nested class or interface are restricted, as specified in §6.5.5.1 . A generic class declaration defines a set of parameterized types ( §4.5 ), one for each possible parameterization of the type parameter section by type arguments. All of these parameterized types share the same class at run time. For instance, executing the code: Vector<String> x = new Vector<String>(); Vector<Integer> y = new Vector<Integer>(); boolean b = x.getClass() == y.getClass(); will result in the variable b holding the value true . It is a compile-time error if a generic class is a direct or indirect subclass of Throwable ( §11.1.1 ). This restriction is needed since the catch mechanism of the Java Virtual Machine works only with non-generic classes. Example 8.1.2-1. Mutually Recursive Type Variable Bounds interface ConvertibleTo<T> { T convert(); } class ReprChange<T extends ConvertibleTo<S>, S extends ConvertibleTo<T>> { T t; void set(S s) { t = s.convert(); } S get() { return t.convert(); } } Example 8.1.2-2. Nested Generic Classes class Seq<T> { T head; Seq<T> tail; Seq() { this(null, null); } Seq(T head, Seq<T> tail) { this.head = head; this.tail = tail; } boolean isEmpty() { return tail == null; } class Zipper<S> { Seq<Pair<T,S>> zip(Seq<S> that) { if (isEmpty() || that.isEmpty()) { return new Seq<Pair<T,S>>(); } else { Seq<T>.Zipper<S> tailZipper = tail.new Zipper<S>(); return new Seq<Pair<T,S>>( new Pair<T,S>(head, that.head), tailZipper.zip(that.tail)); } } } } class Pair<T, S> { T fst; S snd; Pair(T f, S s) { fst = f; snd = s; } } class Test { public static void main(String[] args) { Seq<String> strs = new Seq<String>( \"a\", new Seq<String>(\"b\", new Seq<String>())); Seq<Number> nums = new Seq<Number>( new Integer(1), new Seq<Number>(new Double(1.5), new Seq<Number>())); Seq<String>.Zipper<Number> zipper = strs.new Zipper<Number>(); Seq<Pair<String,Number>> combined = zipper.zip(nums); } } 8.1.3. Inner Classes and Enclosing Instances An inner class is a nested class that is not explicitly or implicitly static . An inner class is one of the following: a member class that is not explicitly or implicitly static ( §8.5 ) a local class that is not implicitly static ( §14.3 ) an anonymous class ( §15.9.5 ) The following nested classes are implicitly static , so are not inner classes: a member enum class ( §8.9 ) a local enum class ( §14.3 ) a member record class ( §8.10 ) a local record class ( §14.3 ) a member class of an interface ( §9.5 ) All of the rules that apply to nested classes apply to inner classes. In particular, an inner class may declare and inherit static members ( §8.2 ), and declare static initializers ( §8.7 ), even though the inner class itself is not static . There are no \"inner interfaces\" because every nested interface is implicitly static ( §9.1.1.3 ). Example 8.1.3-1. Inner Class Declarations and Static Members class HasStatic { static int j = 100; } class Outer { class Inner extends HasStatic { static { System.out.println(\"Hello from Outer.Inner\"); } static int x = 3; static final int y = 4; static void hello() { System.out.println(\"Hello from Outer.Inner.hello\"); } static class VeryNestedButNotInner extends NestedButNotInner {} } static class NestedButNotInner { int z = Inner.x; } interface NeverInner {} // Implicitly static, so never inner } Prior to Java SE 16, an inner class could not declare static initializers, and could only declare static members that were constant variables ( §4.12.4 ). A construct (statement, local variable declaration statement, local class declaration, local interface declaration, or expression) occurs in a static context if the innermost: method declaration, field declaration, constructor declaration, instance initializer, static initializer, or explicit constructor invocation statement which encloses the construct is one of the following: a static method declaration ( §8.4.3.2 , §9.4 ) a static field declaration ( §8.3.1.1 , §9.3 ) a static initializer ( §8.7 ) an explicit constructor invocation statement ( §8.8.7.1 ) Note that a construct which appears in a constructor declaration or an instance initializer does not occur in a static context. The purpose of a static context is to demarcate code that must not refer explicitly or implicitly to the current instance of the class whose declaration lexically encloses the static context. Consequently, code that occurs in a static context is restricted in the following ways: this expressions (both unqualified and qualified) are disallowed ( §15.8.3 , §15.8.4 ). Field accesses, method invocations, and method references may not be qualified by super ( §15.11.2 , §15.12.3 , §15.13.1 ). Unqualified references to instance variables of any lexically enclosing class or interface declaration are disallowed ( §6.5.6.1 ). Unqualified invocations of instance methods of any lexically enclosing class or interface declaration are disallowed ( §15.12.3 ). References to type parameters of any lexically enclosing class or interface declarations are disallowed ( §6.5.5.1 ). References to type parameters, local variables, formal parameters, and exception parameters declared by methods or constructors of any lexically enclosing class or interface declaration that is outside the immediately enclosing class or interface declaration are disallowed ( §6.5.5.1 , §6.5.6.1 ). Declarations of local normal classes (as opposed to local enum classes) and declarations of anonymous classes both specify classes that are inner, yet when instantiated have no immediately enclosing instances ( §15.9.2 ). Class instance creation expressions that instantiate inner member classes must be qualified ( §15.9 ). An inner class C is a direct inner class of a class or interface O if O is the immediately enclosing class or interface declaration of C and the declaration of C does not occur in a static context. If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface. A class C is an inner class of class or interface O if it is either a direct inner class of O or an inner class of an inner class of O . It is unusual, but possible, for the immediately enclosing class or interface declaration of an inner class to be an interface. This only occurs if the class is a local or anonymous class declared in a default or static method body ( §9.4 ). A class or interface O is the zeroth lexically enclosing class or interface declaration of itself . A class O is the n'th lexically enclosing class declaration of a class C if it is the immediately enclosing class declaration of the n-1 'th lexically enclosing class declaration of C . An instance i of a direct inner class C of a class or interface O is associated with an instance of O , known as the immediately enclosing instance of i . The immediately enclosing instance of an object, if any, is determined when the object is created ( §15.9.2 ). An object o is the zeroth lexically enclosing instance of itself . An object o is the n'th lexically enclosing instance of an instance i if it is the immediately enclosing instance of the n-1 'th lexically enclosing instance of i . An instance of an inner local class or an anonymous class whose declaration occurs in a static context has no immediately enclosing instance. Also, an instance of a static nested class ( §8.1.1.4 ) has no immediately enclosing instance. For every superclass S of C which is itself a direct inner class of a class or interface SO , there is an instance of SO associated with i , known as the immediately enclosing instance of i with respect to S . The immediately enclosing instance of an object with respect to its class' direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement ( §8.8.7.1 ). When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing class or interface declaration, the variable of the corresponding lexically enclosing instance is used. Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be final or effectively final ( §4.12.4 ), as specified in §6.5.6.1 . Any local variable used but not declared in an inner class must be definitely assigned ( §16 ( Definite Assignment ) ) before the body of the inner class, or a compile-time error occurs. Similar rules on variable use apply in the body of a lambda expression ( §15.27.2 ). A blank final field ( §4.12.4 ) of a lexically enclosing class or interface declaration may not be assigned within an inner class, or a compile-time error occurs. Example 8.1.3-2. Inner Class Declarations class Outer { int i = 100; static void classMethod() { final int l = 200; class LocalInStaticContext { int k = i; // Compile-time error int m = l; // OK } } void foo() { class Local { // A local class int j = i; } } } The declaration of class LocalInStaticContext occurs in a static context due to being within the static method classMethod . Instance variables of class Outer are not available within the body of a static method. In particular, instance variables of Outer are not available inside the body of LocalInStaticContext . However, local variables from the surrounding method may be referred to without error (provided they are declared final or are effectively final). Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing class declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing class declaration, the instance variable must be defined with respect to an enclosing instance of the inner class. For example, the class Local above has an enclosing instance of class Outer . As a further example: class WithDeepNesting { boolean toBe; WithDeepNesting(boolean b) { toBe = b; } class Nested { boolean theQuestion; class DeeplyNested { DeeplyNested(){ theQuestion = toBe || !toBe; } } } } Here, every instance of WithDeepNesting.Nested.DeeplyNested has an enclosing instance of class WithDeepNesting.Nested (its immediately enclosing instance) and an enclosing instance of class WithDeepNesting (its 2nd lexically enclosing instance). 8.1.4. Superclasses and Subclasses The optional extends clause in a normal class declaration specifies the direct superclass type of the class being declared. ClassExtends: extends ClassType The extends clause must not appear in the definition of the class Object , or a compile-time error occurs, because it is the primordial class and has no direct superclass type. The ClassType must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the ClassType names a class that is sealed ( §8.1.1.2 ) and the class being declared is not a permitted direct subclass of the named class ( §8.1.6 ). It is a compile-time error if the ClassType names a class that is final , because final classes are not allowed to have subclasses ( §8.1.1.2 ). It is a compile-time error if the ClassType names the class Enum , which can only be extended by an enum class ( §8.9 ), or names the class Record , which can only be extended by a record class ( §8.10 ). If the ClassType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. The direct superclass type of a class whose declaration lacks an extends clause is as follows: The class Object has no direct superclass type. For a class other than Object with a normal class declaration, the direct superclass type is Object . For an enum class E , the direct superclass type is Enum < E > . For a record class R , the direct superclass type is Record . For an anonymous class, the direct superclass type is defined in §15.9.5 . The direct superclass of a class is the class named by its direct superclass type. The direct superclass is important because its implementation is used to derive the implementation of the class being declared. The superclass relationship is the transitive closure of the direct superclass relationship. A class A is a superclass of class C if either of the following is true: A is the direct superclass of C . Where a class B is the direct superclass of C , A is a superclass of B , applying this definition recursively. A class is said to be a direct subclass of its direct superclass, and a subclass of each of its superclasses. Example 8.1.4-1. Direct Superclasses and Subclasses class Point { int x, y; } final class ColoredPoint extends Point { int color; } class Colored3DPoint extends ColoredPoint { int z; } // error Here, the relationships are as follows: The class Point is a direct subclass of Object . The class Object is the direct superclass of the class Point . The class ColoredPoint is a direct subclass of class Point . The class Point is the direct superclass of class ColoredPoint . The declaration of class Colored3dPoint causes a compile-time error because it attempts to extend the final class ColoredPoint . Example 8.1.4-2. Superclasses and Subclasses class Point { int x, y; } class ColoredPoint extends Point { int color; } final class Colored3dPoint extends ColoredPoint { int z; } Here, the relationships are as follows: The class Point is a superclass of class ColoredPoint . The class Point is a superclass of class Colored3dPoint . The class ColoredPoint is a subclass of class Point . The class ColoredPoint is a superclass of class Colored3dPoint . The class Colored3dPoint is a subclass of class ColoredPoint . The class Colored3dPoint is a subclass of class Point . A class C directly depends on a class or interface A if A is mentioned in the extends or implements clause of C either as a superclass or superinterface, or as a qualifier in the fully qualified form of a superclass or superinterface name. A class C depends on a class or interface A if any of the following is true: C directly depends on A . C directly depends on an interface I that depends ( §9.1.3 ) on A . C directly depends on a class B that depends on A , applying this definition recursively. It is a compile-time error if a class depends on itself. If circularly declared classes are detected at run time, as classes are loaded, then a ClassCircularityError is thrown ( §12.2.1 ). Example 8.1.4-3. Class Depends on Itself class Point extends ColoredPoint { int x, y; } class ColoredPoint extends Point { int color; } This program causes a compile-time error because class Point depends on itself. 8.1.5. Superinterfaces The optional implements clause in a class declaration specifies the direct superinterface types of the class being declared. ClassImplements: implements InterfaceTypeList InterfaceTypeList: InterfaceType { , InterfaceType } Each InterfaceType must name an accessible interface ( §6.6 ), or a compile-time error occurs. It is a compile-time error if any InterfaceType names a interface that is sealed ( §9.1.1.4 ) and the class being declared is not a permitted direct subclass of the named interface ( §9.1.4 ). If an InterfaceType has type arguments, it must denote a well-formed parameterized type ( §4.5 ), and none of the type arguments may be wildcard type arguments, or a compile-time error occurs. It is a compile-time error if the same interface is named by a direct superinterface type more than once in a single implements clause. This is true even if the interface is named in different ways. Example 8.1.5-1. Illegal Superinterfaces class Redundant implements java.lang.Cloneable, Cloneable { int x; } This program results in a compile-time error because the names java.lang.Cloneable and Cloneable refer to the same interface. A class whose declaration lacks an implements clause has no direct superinterface types, with one exception: an anonymous class may have a superinterface type ( §15.9.5 ). An interface is a direct superinterface of a class if the interface is named by one of the direct superinterface types of the class. An interface I is a superinterface of class C if any of the following is true: I is a direct superinterface of C . C has some direct superinterface J for which I is a superinterface, using the definition of \"superinterface of an interface\" given in §9.1.3 . I is a superinterface of the direct superclass of C . A class can have a superinterface in more than one way. A class is said to directly implement its direct superinterfaces, and to implement all of its superinterfaces. A class is said to be a direct subclass of its direct superinterfaces, and a subclass of all of its superinterfaces. A class may not declare a direct superclass type and a direct superinterface type, or two direct superinterface types, which are, or which have supertypes ( §4.10.2 ) which are, different parameterizations of the same generic interface ( §9.1.2 ), or a parameterization of a generic interface and a raw type naming that same generic interface. In the case of such a conflict, a compile-time error occurs. This requirement was introduced in order to support translation by type erasure ( §4.6 ). Example 8.1.5-2. Superinterfaces interface Colorable { void setColor(int color); int getColor(); } enum Finish { MATTE, GLOSSY } interface Paintable extends Colorable { void setFinish(Finish finish); Finish getFinish(); } class Point { int x, y; } class ColoredPoint extends Point implements Colorable { int color; public void setColor(int color) { this.color = color; } public int getColor() { return color; } } class PaintedPoint extends ColoredPoint implements Paintable { Finish finish; public void setFinish(Finish finish) { this.finish = finish; } public Finish getFinish() { return finish; } } Here, the relationships are as follows: The interface Paintable is a superinterface of class PaintedPoint . The interface Colorable is a superinterface of class ColoredPoint and of class PaintedPoint . The interface Paintable is a subinterface of the interface Colorable , and Colorable is a superinterface of Paintable , as defined in §9.1.3 . The class PaintedPoint has Colorable as a superinterface both because it is a superinterface of ColoredPoint and because it is a superinterface of Paintable . Example 8.1.5-3. Illegal Multiple Inheritance of an Interface interface I<T> {} class B implements I<Integer> {} class C extends B implements I<String> {} Class C causes a compile-time error because it attempts to be a subtype of both I < Integer > and I < String >. Unless the class being declared is abstract , all the abstract member methods of each direct superinterface must be implemented ( §8.4.8.1 ) either by a declaration in this class or by an existing method declaration inherited from the direct superclass or a direct superinterface, because a class that is not abstract is not permitted to have abstract methods ( §8.1.1.1 ). Each default method ( §9.4.3 ) of a superinterface of the class may optionally be overridden by a method in the class; if not, the default method is typically inherited and its behavior is as specified by its default body. It is permitted for a single method declaration in a class to implement methods of more than one superinterface. Example 8.1.5-4. Implementing Methods of a Superinterface interface Colorable { void setColor(int color); int getColor(); } class Point { int x, y; }; class ColoredPoint extends Point implements Colorable { int color; } This program causes a compile-time error, because ColoredPoint is not an abstract class but fails to provide an implementation of methods setColor and getColor of the interface Colorable . In the following program: interface Fish { int getNumberOfScales(); } interface Piano { int getNumberOfScales(); } class Tuna implements Fish, Piano { // You can tune a piano, but can you tuna fish? public int getNumberOfScales() { return 91; } } the method getNumberOfScales in class Tuna has a name, signature, and return type that matches the method declared in interface Fish and also matches the method declared in interface Piano ; it is considered to implement both. On the other hand, in a situation such as this: interface Fish { int getNumberOfScales(); } interface StringBass { double getNumberOfScales(); } class Bass implements Fish, StringBass { // This declaration cannot be correct, // no matter what type is used. public ?? getNumberOfScales() { return 91; } } it is impossible to declare a method named getNumberOfScales whose signature and return type are compatible with those of both the methods declared in interface Fish and in interface StringBass , because a class cannot have multiple methods with the same signature and different primitive return types ( §8.4 ). Therefore, it is impossible for a single class to implement both interface Fish and interface StringBass ( §8.4.8 ). 8.1.6. Permitted Direct Subclasses The optional permits clause in a normal class declaration specifies all the classes intended as direct subclasses of the class being declared ( §8.1.1.2 ). ClassPermits: permits TypeName { , TypeName } It is a compile-time error if a class declaration has a permits clause but no sealed modifier. Every TypeName must name an accessible class ( §6.6 ), or a compile-time error occurs. It is a compile-time error if the same class is specified more than once in a permits clause. This is true even if the class is named in different ways. The canonical name of a class does not need to be used in a permits clause, but a permits clause can only specify a class once. For example, the following program fails to compile: package p; sealed class A permits B, C, p.B {} // error non-sealed class B extends A {} non-sealed class C extends A {} If a sealed class C is associated with a named module ( §7.3 ), then every class specified in the permits clause of C 's declaration must be associated with the same module as C , or a compile-time error occurs. If a sealed class C is associated with an unnamed module ( §7.7.5 ), then every class specified in the permits clause of C 's declaration must belong to the same package as C , or a compile-time error occurs. A sealed class and its direct subclasses need to refer to each other in a circular fashion, in permits and extends clauses, respectively. Therefore, in a modular codebase, they must be co-located in the same module, as classes in different modules cannot refer to each other in a circular fashion. Co-location is desirable in any case because a sealed class hierarchy should always be declared within a single maintenance domain, where the same developer or group of developers is responsible for maintaining the hierarchy. A named module typically represents a maintenance domain in a modular codebase. If the declaration of a sealed class C has a permits clause, then the permitted direct subclasses of C are the classes specified by the permits clause. Every permitted direct subclass specified by the permits clause must be a direct subclass of C ( §8.1.4 ), or a compile-time error occurs. If the declaration of a sealed class C lacks a permits clause, then the permitted direct subclasses of C are as follows: If C is not an enum class, then its permitted direct subclasses are those classes declared in the same compilation unit as C ( §7.3 ) which have a canonical name ( §6.7 ) and whose direct superclass is C . That is, the permitted direct subclasses are inferred as the classes in the same compilation unit that specify C as their direct superclass. The requirement for a canonical name means that no local classes or anonymous classes will be considered. It is a compile-time error if the declaration of a sealed class C lacks a permits clause and C has no permitted direct subclasses. If C is an enum class, then its permitted direct subclasses, if any, are specified in §8.9 . 8.1.7. Class Body and Member Declarations A class body may contain declarations of members of the class, that is, fields ( §8.3 ), methods ( §8.4 ), classes, and interfaces ( §8.5 ). A class body may also contain instance initializers ( §8.6 ), static initializers ( §8.7 ), and declarations of constructors ( §8.8 ) for the class. ClassBody: { { ClassBodyDeclaration } } ClassBodyDeclaration: ClassMemberDeclaration InstanceInitializer StaticInitializer ConstructorDeclaration ClassMemberDeclaration: FieldDeclaration MethodDeclaration ClassDeclaration InterfaceDeclaration ; The scope and shadowing of a declaration of a member m declared in or inherited by a class C is specified in §6.3 and §6.4.1 . If C is a nested class, there may be definitions of the same kind (variable, method, or type) and name as m in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member m declared in or inherited by C shadows the other definitions of the same kind and name.",
  "metadata": {
    "java_version": "24",
    "section_number": "8.8",
    "section_title": "Chapter 8. Classes",
    "chapter_title": "Chapter 8. Classes"
  },
  "url": "https://docs.oracle.com/javase/specs/jls/se24/html/jls-8.html#jls-8.8",
  "section_name": "constructors",
  "downloaded_at": "2025-05-27T13:20:47.409154"
}